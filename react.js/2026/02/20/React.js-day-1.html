<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[React.js] React의 학습커브는 왜 가파른 것일까? - Engineering Log</title>
<meta name="description" content="React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Engineering Log">
<meta property="og:title" content="[React.js] React의 학습커브는 왜 가파른 것일까?">
<meta property="og:url" content="https://hwp-log.github.io/react.js/2026/02/20/React.js-day-1.html">


  <meta property="og:description" content="React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다.">







  <meta property="article:published_time" content="2026-02-20T00:00:00+00:00">






<link rel="canonical" href="https://hwp-log.github.io/react.js/2026/02/20/React.js-day-1.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Engineering Log Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <link rel="icon" type="image/png" href="/assets/images/favicon.png">

<style>
    /* 홈에서 Recent Posts 헤더 숨기기 */
    .layout--home h3.archive__subtitle {
        display: none !important;
    }
</style>
  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo.png" alt="Engineering Log"></a>
        
        <a class="site-title" href="/">
          Engineering Log
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork" >
    
    <meta itemprop="headline"
      content="[React.js] React의 학습커브는 왜 가파른 것일까?">
    
    <meta itemprop="description" content="React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다.">
    
    
    <meta itemprop="datePublished" content="2026-02-20T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
      <header>
        <h1 id="page-title" class="page__title" itemprop="headline">
          <a href="https://hwp-log.github.io/react.js/2026/02/20/React.js-day-1.html" itemprop="url">[React.js] React의 학습커브는 왜 가파른 것일까?</p>
</a>
        </h1>
        

<p class="page__meta">
    
    <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2026-02-20T00:00:00+00:00">2026-02-20</time>
    </span>
    

    <!-- Hits.sh View Counter -->
    <span id="page-views" data-url="/react.js/2026/02/20/React.js-day-1.html" style="margin-left: 10px;"></span>
</p>
      </header>
      

      <section class="page__content" itemprop="text">
        
        <p>React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다.</p>

<p>실제로 본인도 JS로 각 dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응되는 컴포넌트 단위 사고로의 전환에 어려운 부분이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고 이에 맞는 프레임워크를 만들게 된 것일까? 이번 글에서는 이러한 ‘구조가 탄생된 배경을 이해’하고 ‘구조에 맞는 기술’이 왜 만들어 졌는지에 대해 다뤄보고자 한다.</p>

<h2 id="2011년-facebook은-더-복잡해지고-있었다">2011년, FaceBook은 더 복잡해지고 있었다.</h2>

<p>15년전인 2011년, 페이스북은 초기의 모습과 달리 점점 구조가 복잡해 지기 시작했다. 페이스북 광고 및 뉴스피드와 같은 기능이 들어가며, 더욱 많은 인력이 요구되었고 팀원 수와 앱 기능 관리는 업무 속도의 효율을 떨어트리게 되었다. 이는 앱의 업데이트 속도를 늦추게 되는 결과를 낳게 되었다.</p>

<p><img src="/assets/post_images/2026-02-25/facebook.png" alt="페이스북, 2004년(좌)&amp; 2011년(우)" /><br />
좌 : 2004년 페이스북 | 우 : 2011년 페이스북<br />
출처 : <a href="https://www.cnet.com/pictures/facebook-then-and-now-pictures/">CNET</a></p>

<p>이 상태에서 페이스북의 엔지니어들은 코드의 유지보수 조차 어렵게 되었는데, 이는 필연적으로 업무 프로세스를 효율적으로 만드는 도구가 필요했던 것이다. 이것이 React.js가 생기게 된 계기이다.</p>

<h2 id="업데이트-속도를-늦추게-한-본질적인-원인은-무엇이였을까">업데이트 속도를 늦추게 한 본질적인 원인은 무엇이였을까?</h2>

<p>원래 FaceBook은 MVC패턴의 양방향 모델 구조였다. 이는 초기의 단순구조였던, FaceBook에서는 채용이 가능했던 구조였지만, 점점 복잡해 지면서 양방향 구조의 한계를 느끼게 된다. 그렇다면 그 구조의 한계는 무엇이였을까? 바로 예측불가 코드였던 것이다.</p>

<p><img src="/assets/post_images/2026-02-25/unpredcitable_code.png" alt="React.js Conf 2015 Keynotes" />
출처 : <a href="https://www.youtube.com/watch?v=KVZ-P-ZI6W4&amp;list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr&amp;index=2">React.js Conf 2015 Keynote</a></p>

<p>아래의 단방향과 양방향에 내용을 넣어보자. 어떻게 작동하는가?</p>

<p>좋아, 네가 방금 올린 문서에서 딱 한 줄만 수정한 버전 전체를 그대로 줄게.
아래를 통째로 포스트 파일에 붙여 쓰면 돼.</p>

<h2 id="text">text</h2>
<p>layout: single
title: “[React.js] React의 학습커브는 왜 가파른 것일까?”
date: 2026-02-20
categories: [React.js]
—
React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다.</p>

<p>실제로 본인도 JS로 각 dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응되는 컴포넌트 단위 사고로의 전환에 어려운 부분이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고 이에 맞는 프레임워크를 만들게 된 것일까? 이번 글에서는 이러한 ‘구조가 탄생된 배경을 이해’하고 ‘구조에 맞는 기술’이 왜 만들어 졌는지에 대해 다뤄보고자 한다.</p>

<h2 id="2011년-facebook은-더-복잡해지고-있었다-1">2011년, FaceBook은 더 복잡해지고 있었다.</h2>

<p>15년전인 2011년, 페이스북은 초기의 모습과 달리 점점 구조가 복잡해 지기 시작했다. 페이스북 광고 및 뉴스피드와 같은 기능이 들어가며, 더욱 많은 인력이 요구되었고 팀원 수와 앱 기능 관리는 업무 속도의 효율을 떨어트리게 되었다. 이는 앱의 업데이트 속도를 늦추게 되는 결과를 낳게 되었다.</p>

<p><img src="/assets/post_images/2026-02-25/facebook.png" alt="페이스북, 2004년(좌)&amp; 2011년(우)" /><br />
좌 : 2004년 페이스북 | 우 : 2011년 페이스북<br />
출처 : <a href="https://www.cnet.com/pictures/facebook-then-and-now-pictures/">CNET</a></p>

<p>이 상태에서 페이스북의 엔지니어들은 코드의 유지보수 조차 어렵게 되었는데, 이는 필연적으로 업무 프로세스를 효율적으로 만드는 도구가 필요했던 것이다. 이것이 React.js가 생기게 된 계기이다.</p>

<h2 id="업데이트-속도를-늦추게-한-본질적인-원인은-무엇이였을까-1">업데이트 속도를 늦추게 한 본질적인 원인은 무엇이였을까?</h2>

<p>원래 FaceBook은 MVC패턴의 양방향 모델 구조였다. 이는 초기의 단순구조였던, FaceBook에서는 채용이 가능했던 구조였지만, 점점 복잡해 지면서 양방향 구조의 한계를 느끼게 된다. 그렇다면 그 구조의 한계는 무엇이였을까? 바로 예측불가 코드였던 것이다.</p>

<p><img src="/assets/post_images/2026-02-25/unpredcitable_code.png" alt="React.js Conf 2015 Keynotes" />
출처 : <a href="https://www.youtube.com/watch?v=KVZ-P-ZI6W4&amp;list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr&amp;index=2">React.js Conf 2015 Keynote</a></p>

<p>아래의 단방향과 양방향에 내용을 넣어보자. 어떻게 작동하는가?</p>

<div id="data-flow-demo">
  <h1>대규모 앱 데이터 흐름 시각화</h1>
  <p>입력창에 글자를 타이핑하며 데이터가 어떻게 전파되는지 관찰하세요.</p>

  <div class="container">
    <!-- 단방향 -->
    <div class="box" id="one-way-container">
      <h2>단방향 (One-way)</h2>
      <div class="state-box">중앙 Store (State): <span id="one-way-state">""</span></div>
      <input type="text" id="one-way-input" placeholder="여기에 입력 (View)" />
      <div class="component-tree">
        <div style="font-weight:bold; margin-bottom:5px;">Component Tree (하향식 전파)</div>
        <div class="node" id="ow-node-1">Header 컴포넌트: <span class="val">""</span></div>
        <div class="node" id="ow-node-2">Content 컴포넌트: <span class="val">""</span></div>
        <div class="node" id="ow-node-3">Footer 컴포넌트: <span class="val">""</span></div>
      </div>
      <div class="log" id="one-way-log">이벤트 로그가 여기에 표시됩니다.</div>
      <p style="font-size: 12px; color: #888;">* 입력 -&gt; Action 발생 -&gt; State 변경 -&gt; UI 전체 전파</p>
    </div>

    <!-- 양방향 -->
    <div class="box" id="two-way-container">
      <h2>양방향 (Two-way)</h2>
      <div class="state-box">Model (Data Object): <span id="two-way-state">""</span></div>
      <input type="text" id="two-way-input" placeholder="여기에 입력 (View/Model)" />
      <div class="component-tree">
        <div style="font-weight:bold; margin-bottom:5px;">Connected Views (자동 동기화)</div>
        <div class="node" id="tw-node-1">프로필 이름: <span class="val">""</span></div>
        <div class="node" id="tw-node-2">알림 설정: <span class="val">""</span></div>
        <div class="node" id="tw-node-3">실시간 미리보기: <span class="val">""</span></div>
      </div>
      <div class="log" id="two-way-log">이벤트 로그가 여기에 표시됩니다.</div>
      <p style="font-size: 12px; color: #888;">* 입력 = State 변경 (즉시 연결)</p>
    </div>
  </div>
</div>

<style>
  /* data-flow-demo 영역에만 스타일 적용되도록 앞에 #data-flow-demo 붙임 */
  #data-flow-demo { font-family: sans-serif; }
  #data-flow-demo .container { display: flex; gap: 40px; width: 100%; max-width: 1000px; }
  #data-flow-demo .box { flex: 1; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); position: relative; }
  #data-flow-demo h2 { text-align: center; color: #333; margin-bottom: 30px; }
  #data-flow-demo .component-tree { border: 2px dashed #ccc; padding: 15px; margin-top: 20px; border-radius: 8px; }
  #data-flow-demo .node { padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px; background: #fafafa; font-size: 13px; transition: all 0.3s; }
  #data-flow-demo .active { background: #e3f2fd; border-color: #2196f3; transform: scale(1.02); }
  #data-flow-demo .state-box { background: #333; color: #fff; padding: 10px; border-radius: 6px; margin-bottom: 20px; text-align: center; }
  #data-flow-demo input { width: 100%; padding: 10px; box-sizing: border-box; margin-bottom: 10px; border: 2px solid #ddd; border-radius: 4px; outline: none; }
  #data-flow-demo input:focus { border-color: #2196f3; }
  #data-flow-demo .log { font-size: 12px; color: #666; height: 100px; overflow-y: auto; border: 1px solid #eee; padding: 5px; margin-top: 10px; background: #f9f9f9; }
</style>

<script>
  (function() {
    // 단방향
    const owInput = document.getElementById('one-way-input');
    const owState = document.getElementById('one-way-state');
    const owLog = document.getElementById('one-way-log');
    const owNodes = [
      document.getElementById('ow-node-1'),
      document.getElementById('ow-node-2'),
      document.getElementById('ow-node-3')
    ];

    owInput.addEventListener('input', (e) => {
      const val = e.target.value;
      addLog(owLog, `[Action] 유저 입력 발생: ${val}`);

      setTimeout(() => {
        owState.innerText = `"${val}"`;
        addLog(owLog, `[State Update] 중앙 저장소 데이터 갱신`);

        owNodes.forEach((node, index) => {
          setTimeout(() => {
            node.querySelector('.val').innerText = `"${val}"`;
            node.classList.add('active');
            addLog(owLog, `[Render] 하위 컴포넌트 ${index+1} 갱신`);
            setTimeout(() => node.classList.remove('active'), 300);
          }, index * 100);
        });
      }, 200);
    });

    // 양방향
    const twInput = document.getElementById('two-way-input');
    const twState = document.getElementById('two-way-state');
    const twLog = document.getElementById('two-way-log');
    const twNodes = [
      document.getElementById('tw-node-1'),
      document.getElementById('tw-node-2'),
      document.getElementById('tw-node-3')
    ];

    twInput.addEventListener('input', (e) => {
      const val = e.target.value;
      twState.innerText = `"${val}"`;
      addLog(twLog, `[Sync] Model 데이터 즉시 변경`);

      twNodes.forEach(node => {
        node.querySelector('.val').innerText = `"${val}"`;
        node.classList.add('active');
        setTimeout(() => node.classList.remove('active'), 300);
      });
      addLog(twLog, `[Update] 연결된 모든 View 동시 갱신`);
    });

    function addLog(container, text) {
      const entry = document.createElement('div');
      entry.innerText = `> ${text}`;
      container.prepend(entry);
    }
  })();
</script>

<p>단방향의 경우에는 어느 컴포넌트가 작동했는지 눈에 들어올 것이다. 그러나 양방향의 경우에는 컴포넌트가 동시에 갱신되어 어느부분이 작동하는지 한눈에 들어오지 않을 것이다. 이 상태에서 양방향의 컴포넌트 개수가 많아진다면 유지보수가 어려울 것이다.</p>

<p>…작성중…</p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2026-02-20T00:00:00+00:00">2026-02-20</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/javascript/2026/02/20/JS-day-1.html" class="pagination--pager" title="[JavaScript] var, let, const는 왜 생겨났을까?">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  

  <!-- Hits.sh View Counter Script -->
  <script>
    (function () {
      var viewElement = document.getElementById('page-views');
      if (!viewElement) return;

      var pageUrl = viewElement.getAttribute('data-url');

      // 배지 이미지 (투명 배경, 수직 정렬)
      var img = document.createElement('img');
      img.src = 'https://hits.sh/hwp-log.github.io' + pageUrl + '.svg?view=total&style=flat-square&label=views&color=00000000&labelColor=00000000&hit=7a8288';
      img.alt = 'Views';
      img.style.verticalAlign = 'text-bottom';
      img.style.height = '16px';

      viewElement.appendChild(img);
    })();
  </script>
</div>
      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2026 <a href="https://hwp-log.github.io">Engineering Log</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
