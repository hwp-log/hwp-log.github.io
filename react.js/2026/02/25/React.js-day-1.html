<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[React.js] React의 학습커브는 왜 가파른 것일까? - Engineering Log</title>
<meta name="description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Engineering Log">
<meta property="og:title" content="[React.js] React의 학습커브는 왜 가파른 것일까?">
<meta property="og:url" content="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html">


  <meta property="og:description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">







  <meta property="article:published_time" content="2026-02-25T00:00:00+00:00">






<link rel="canonical" href="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Engineering Log Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <link rel="icon" type="image/png" href="/assets/images/favicon.png">

<style>
    /* 홈에서 Recent Posts 헤더 숨기기 */
    .layout--home h3.archive__subtitle {
        display: none !important;
    }
</style>
  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo.png" alt="Engineering Log"></a>
        
        <a class="site-title" href="/">
          Engineering Log
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork" >
    
    <meta itemprop="headline"
      content="[React.js] React의 학습커브는 왜 가파른 것일까?">
    
    <meta itemprop="description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">
    
    
    <meta itemprop="datePublished" content="2026-02-25T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
      <header>
        <h1 id="page-title" class="page__title" itemprop="headline">
          <a href="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html" itemprop="url">[React.js] React의 학습커브는 왜 가파른 것일까?</p>
</a>
        </h1>
        

<p class="page__meta">
    
    <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2026-02-25T00:00:00+00:00">2026-02-25</time>
    </span>
    

    <!-- Hits.sh View Counter -->
    <span id="page-views" data-url="/react.js/2026/02/25/React.js-day-1.html" style="margin-left: 10px;"></span>
</p>
      </header>
      

      <section class="page__content" itemprop="text">
        
        <p>React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.</p>

<p>실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 왜 만들게 된 것일까?</p>

<p>이번 글에서는</p>
<ul>
  <li>React의 ‘트리구조가 탄생하게 된 배경’을 먼저 살펴보고,</li>
  <li>그 구조에 맞는 ‘개념과 기술’이 어떻게 만들어 졌는지 정리해 보고자 한다.</li>
</ul>

<h2 id="탄생배경-1-2011년-facebook은-점점-복잡해지고-있었다">[탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.</h2>

<p>15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다.</p>

<p>문제는 기능과 팀원이 늘어날수록, 기능간의 영향을 주고받는 내용이 많아졌다는 것이다. 특히, 하나의 기능을 수정하면 예상치 못한 다른 부분이 깨지고, 깨진부분을 이해하고 수정하는 데 많은 비용이 들었다. 비용의 증가는 신기능 출시 및 개선 속도에도 영향을 미치기 시작했다.</p>

<p><img src="/assets/post_images/2026-02-25/facebook.png" alt="페이스북, 2004년(좌)&amp; 2011년(우)" /><br />
좌 : 2004년 페이스북 | 우 : 2011년 페이스북<br />
출처 : <a href="https://www.cnet.com/pictures/facebook-then-and-now-pictures/">CNET</a></p>

<p>이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식 방식이 필요하게 된 것이다.</p>

<p>이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크 React.js가 탄생하게 된다.</p>

<h2 id="탄생배경-2-그렇다면-니즈가-쌓이게-된-원인은-무엇이었을까">[탄생배경 2] 그렇다면 니즈가 쌓이게 된 원인은 무엇이었을까?</h2>

<p>facebook은 MVC 스타일 구조와 양방향/단방향 데이터 흐름 패턴을 많이 사용하고 있었다. 이 방식은 초기화면처럼 단순할 때, 잘 동작했었다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc00.png" alt="mvc패턴" /><br />
출처 : 본인</p>

<p>그러나 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다. 그 한계는 앞서 말했던 ‘기능간의 영향을 주고 받는 내용이 많아진점’, 그리고 이러한 내용이 대량으로 발생하면서 연쇄적인 업데이트(cascading updates) 폭증하게 된 것이다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc22.png" alt="mvc패턴" /><br />
출처 : 본인</p>

<p>그렇다면 연쇄적인 업데이트는 무엇을 말하는건가? MVC패턴을 생각해보자, 사용자가 입력을 하면 View에서 Controller를 거쳐 Model이 갱신되고, 다시 갱신된 Model은 View에 재랜더링 하게되는 방식이다.</p>

<p>즉, [ 입력(Input) -&gt; 모델(Model) -&gt; 출력(Output) ]의 패턴 인것이다. 
이 사이클은 여기서만 끝난다면, “어느 지점에서 어떤 값이 바뀌는지” 쉽게 예측할 수 있다.</p>

<p>문제는… 여기서 끝이 아니였던 것이다. 만약 세번째 단계인, ‘출력단계(Output)에서 끝나지 않고, 자동으로 입력(Input) 트리거’가 다시 작동한다면 어떻게 될까?</p>

<p>[ 입력(Input) -&gt; 모델(Model) -&gt; 출력(Output) &amp; 자동 트리거 입력(Input) -&gt; 모델(Model -&gt; …)]</p>

<p>출력 이후, 자동 트리거 입력(Input)이 작동하여 Model, View를 다시 왕복 하게 될것이다. 이런 패턴이 여러기능에서 발생하여, ‘어디서 무엇이 전파되고 다시 재전파 되는지’를 알 수 없게 되는 현상이 연쇄적인 업데이트(cascading updates)인 것이다.</p>

<p>물론, 기능이 적은 상태에서는 많은 데이터를 관리하지 않았기 때문에 추적이 가능했을 것이다. 하지만 점차 이러한 패턴이 폭증하게 되었고 이는 유지보수의 니즈로서 구체화 되기 시작했다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc.png" alt="페이스북의 복잡해진 MVC패턴" /><br />
출처 : <a href="https://www.infoq.com/news/2014/05/facebook-mvc-flux/">InfoQ</a></p>

<h2 id="사례와-해결책-안-읽은-메시지-기능과-flux-패턴">[사례와 해결책] 안 읽은 메시지 기능과 Flux 패턴</h2>

<p>그렇다면 그 사례는 어떤 것이 있을까? 페이스북에서는 “실제로 새 메시지가 없는데도 새 메시지가 있다고 사용자에게 알리는 채팅버그”가 있었다. 이는 앞서 말한 “연쇄적인 업데이트 내용이 폭증”하면서, 모델에 수시로 값이 갱신되고 어느 부분에서 값이 바뀌었는지 알 수 없었기에 생긴 버그였다.</p>

<p>그리고 이를 해결하고자 했던 패턴이 Flux패턴이였다.</p>

<p><img src="/assets/post_images/2026-02-25/flux.png" alt="flux 패턴" /><br />
출처 : <a href="https://facebookarchive.github.io/flux/docs/in-depth-overview/">InfoQ</a></p>

<p>처음 본다면, 헷갈릴 수 있는데 핵심만 말하자면 아래와 같다.</p>

<ol>
  <li>핵심은 Store에 저장되는 ‘기능별 상태정보’ 이다.</li>
  <li>연쇄적인 업데이트가 많아지면… 어느 Model에서 값이 변경 되었는지 알 수 없었다.</li>
  <li>이를 해결해 주는게 dispatcher과 Store(정해진 도메인들이 모인 Model영역)이다.</li>
  <li>dispatcher는 액션을 모든 Store에 전달하는 단일통로이다.</li>
  <li>dispatcher는 한 액션이 처리되는 동안 상태변경이 단 한번의 path로만 일어나도록 강제한다.</li>
  <li>“안 읽은 메시지”,”채팅 목록”등의 관련 기능은 모두 Store에서 값을 읽기 때문에, 값이 헷갈리지 않게 된다.</li>
  <li>예시 이미지에서는 Store 하나로 고정되어 있지만, 이전 MVC패턴에서는 관련 없는 모델로 값이 튀는 것이 문제였다.</li>
</ol>

<p>이렇게 보면, Flux는 “View/Model이 어디서 끝나는지 모르는 스파게티 흐름”을 
한 방향으로 고정하고, 최종책임을 Store에서 확인 할 수 있는 구조가 되는 것이다.</p>

<p>간단히 말하자면…</p>

<ul>
  <li>양방향 :</li>
</ul>

<p>[Model기능1 &lt;-&gt; ViewA &lt;-&gt; Model기능?? &lt;-&gt; View??]</p>

<ul>
  <li>한방향 :</li>
</ul>

<p>[ViewA -&gt; Action -&gt; Dispatcher -&gt; Store(기능A)]
[ViewA -&gt; Action -&gt; Dispatcher -&gt; Store(기능B)]</p>

<p>즉, 핵심은 Dispatcher를 통한 ‘고정된 경로를 거쳐 지정된 Store만 갱신해 준다는 것이다.’
이렇듯 ‘여러 모델’로 값이 튀지 않게 ‘정해진 도메인 기능들의 모델영역(해당 기능의 Store)’로만 가기 때문에 단방향이라고 말하는 것이다.</p>

<p>이는 ‘고정된 경로’랑 ‘저장장소’를 제공하여, 어디서 어떤 상태가 바뀌는지 추적을 쉽게 할 수 있게 해준다. 또한 하나의 액션이 발생하면, 관련된 여러 Store가 그 액션을 각자 해석해 상태를 갱신할 수 있겠지만, 이 모든 과정은 항상 Action -&gt; Dispatcher -&gt; Store -&gt; View 라는 고정된 흐름 안에서 일어나기 때문에, 기존의 “예상치 못한 곳에서 값이 튀는” 현상을 크게 줄일 수 있는 것이다.</p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2026-02-25T00:00:00+00:00">2026-02-25</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/javascript/2026/02/20/JS-day-1.html" class="pagination--pager" title="[JavaScript] var, let, const는 왜 생겨났을까?">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  

  <!-- Hits.sh View Counter Script -->
  <script>
    (function () {
      var viewElement = document.getElementById('page-views');
      if (!viewElement) return;

      var pageUrl = viewElement.getAttribute('data-url');

      // 배지 이미지 (투명 배경, 수직 정렬)
      var img = document.createElement('img');
      img.src = 'https://hits.sh/hwp-log.github.io' + pageUrl + '.svg?view=total&style=flat-square&label=views&color=00000000&labelColor=00000000&hit=7a8288';
      img.alt = 'Views';
      img.style.verticalAlign = 'text-bottom';
      img.style.height = '16px';

      viewElement.appendChild(img);
    })();
  </script>
</div>
      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2026 <a href="https://hwp-log.github.io">Engineering Log</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
