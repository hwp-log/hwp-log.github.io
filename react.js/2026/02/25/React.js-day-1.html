<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.27.3 by Michael Rose
  Copyright 2013-2025 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->

<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[React.js] React의 학습커브는 왜 가파른 것일까? - Engineering Log</title>
<meta name="description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">



<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Engineering Log">
<meta property="og:title" content="[React.js] React의 학습커브는 왜 가파른 것일까?">
<meta property="og:url" content="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html">


  <meta property="og:description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">







  <meta property="article:published_time" content="2026-02-25T00:00:00+00:00">






<link rel="canonical" href="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html">












<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Engineering Log Feed">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
  
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css"></noscript>



    <link rel="icon" type="image/png" href="/assets/images/favicon.png">

<style>
    /* 홈에서 Recent Posts 헤더 숨기기 */
    .layout--home h3.archive__subtitle {
        display: none !important;
    }
</style>
  </head>

  <body class="layout--single" dir="ltr">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo.png" alt="Engineering Log"></a>
        
        <a class="site-title" href="/">
          Engineering Log
          
        </a>
        <ul class="visible-links"></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      





<div id="main" role="main">
  


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork" >
    
    <meta itemprop="headline"
      content="[React.js] React의 학습커브는 왜 가파른 것일까?">
    
    <meta itemprop="description" content="React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.">
    
    
    <meta itemprop="datePublished" content="2026-02-25T00:00:00+00:00">
    

    <div class="page__inner-wrap">
      
      <header>
        <h1 id="page-title" class="page__title" itemprop="headline">
          <a href="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html" itemprop="url">[React.js] React의 학습커브는 왜 가파른 것일까?</p>
</a>
        </h1>
        

<p class="page__meta">
    
    <span class="page__meta-date">
        <i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i>
        <time datetime="2026-02-25T00:00:00+00:00">2026-02-25</time>
    </span>
    

    <!-- Hits.sh View Counter -->
    <span id="page-views" data-url="/react.js/2026/02/25/React.js-day-1.html" style="margin-left: 10px;"></span>
</p>
      </header>
      

      <section class="page__content" itemprop="text">
        
        <p>React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.</p>

<p>실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 만들게 된 것일까?</p>

<p>이번 글에서는</p>
<ul>
  <li>React의 ‘트리구조가 탄생하게 된 배경’을 먼저 살펴보고,</li>
  <li>그 구조에 ‘맞는 개념과 기술’이 어떻게 만들어 졌는지 정리해 보고자 한다.</li>
</ul>

<h2 id="탄생배경-1-2011년-facebook은-점점-복잡해지고-있었다">[탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.</h2>

<p>15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다.</p>

<p>문제는 기능과 팀원이 늘어날수록, 서로 영향을 주고받는 ‘연쇄적인 업데이트’가 잦아졌다는 것이다. 한 부분을 수정하면 예상치 못한 다른 부분이 깨지고, 전체 앱을 이해하고 수정하는 데 드는 비용이 크게 증가했던 것이다. 결과적으로 신기능 출시와 개선 속도도 점점 느려지기 시작했다.</p>

<p><img src="/assets/post_images/2026-02-25/facebook.png" alt="페이스북, 2004년(좌)&amp; 2011년(우)" /><br />
좌 : 2004년 페이스북 | 우 : 2011년 페이스북<br />
출처 : <a href="https://www.cnet.com/pictures/facebook-then-and-now-pictures/">CNET</a></p>

<p>이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식 방식이 필요하게 된 것이다.</p>

<p>이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크인 React.js가 탄생하게 된다.</p>

<h2 id="탄생배경-2-그렇다면-원인이였던-연쇄적인-업데이트는-무엇이였을까">[탄생배경 2] 그렇다면 원인이였던 ‘연쇄적인 업데이트’는 무엇이였을까?</h2>

<p>원래 facebook은 MVC패턴과 양방향 데이터 흐름에 기반한 구조를 사용하고 있었다. 이 방식은 초기처럼 화면이 단순할 때, 잘 동작했었지만, 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다.</p>

<p>그 한계는 앞서 말했던 연쇄적인 업데이트(cascading updates)였던 것이다. MVC패턴을 생각해보자, 사용자가 입력을 하면 View에서 Controller를 거쳐 Model이 갱신되고, 갱신된 Model은 다시 View에 재랜더링 되는 방식이다.
즉 입력(Input) -&gt; 모델(Model) -&gt; 출력(Output)으로 고정된 것이다.</p>

<p>이 사이클이 여기서만 끝난다면, “어느 지점에서 어떤 값이 바뀌는지” 쉽게 예측할 수 있다.
문제는 여기서 끝이 아니였던 것이다. 출력단계(View)에서 끝나지 않고, 화면 변화에 반응해 다시 Model을 건드리는 자동 입력(Input) 트리거가 작동한다면 어떻게 될까?</p>

<p>한 Input이 자동 트리거의 작동을 통해 Model, View를 여러번 왕복 하게 되면서, 어디서 무엇이 전파되고 다시 재전파 되는지 추적하기가 어려워진다.(물론 기능이 적은 앱에서는 많은 데이터를 관리하지 않기에 추적이 가능하다.)</p>

<p>그러나 기능이 추가된다면, 이에 영향을 주는 자동 인풋 트리거의 수가 증가하여 모델의 값이 어디가 얼마나 갱신될지 예측이 불가능 한것이다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc.png" alt="페이스북의 복잡해진 MVC패턴" /><br />
출처 : <a href="https://www.infoq.com/news/2014/05/facebook-mvc-flux/">InfoQ</a></p>

<p>이런 예측불가능한 상황을 해결하기 위해, 기존의 양방향 패턴을 단방향 패턴으로 바꾸게 된다.</p>

<p>…작성중…</p>

        
      </section>

      <footer class="page__meta">
        
        


        

  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time class="dt-published" datetime="2026-02-25T00:00:00+00:00">2026-02-25</time></p>

      </footer>

      

      
  <nav class="pagination">
    
      <a href="/javascript/2026/02/20/JS-day-1.html" class="pagination--pager" title="[JavaScript] var, let, const는 왜 생겨났을까?">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>


    </div>

    
  </article>

  
  

  <!-- Hits.sh View Counter Script -->
  <script>
    (function () {
      var viewElement = document.getElementById('page-views');
      if (!viewElement) return;

      var pageUrl = viewElement.getAttribute('data-url');

      // 배지 이미지 (투명 배경, 수직 정렬)
      var img = document.createElement('img');
      img.src = 'https://hits.sh/hwp-log.github.io' + pageUrl + '.svg?view=total&style=flat-square&label=views&color=00000000&labelColor=00000000&hit=7a8288';
      img.alt = 'Views';
      img.style.verticalAlign = 'text-bottom';
      img.style.height = '16px';

      viewElement.appendChild(img);
    })();
  </script>
</div>
      
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        

<div class="page__footer-follow">
  <ul class="social-icons">
    

    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>


<div class="page__footer-copyright">&copy; 2026 <a href="https://hwp-log.github.io">Engineering Log</a>. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/jekyll-themes/minimal-mistakes/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>









  </body>
</html>
