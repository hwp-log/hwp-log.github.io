<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="https://hwp-log.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://hwp-log.github.io/" rel="alternate" type="text/html" /><updated>2026-03-01T04:15:27+00:00</updated><id>https://hwp-log.github.io/feed.xml</id><title type="html">Engineering Log</title><subtitle>프로젝트, 기술 탐구, 공부 내용을 한 데 모은 개인 기록 저장소</subtitle><entry><title type="html">[React.js] React의 학습커브는 왜 가파른 것일까?</title><link href="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html" rel="alternate" type="text/html" title="[React.js] React의 학습커브는 왜 가파른 것일까?" /><published>2026-02-25T00:00:00+00:00</published><updated>2026-02-25T00:00:00+00:00</updated><id>https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1</id><content type="html" xml:base="https://hwp-log.github.io/react.js/2026/02/25/React.js-day-1.html"><![CDATA[<p>React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.</p>

<p>실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 왜 만들게 된 것일까?</p>

<p>이번 글에서는</p>
<ul>
  <li>React의 ‘구조가 탄생하게 된 배경’을 먼저 살펴보고,</li>
  <li>그 구조에 맞는 ‘개념과 기술’이 어떻게 만들어 졌는지 정리해 보고자 한다.</li>
</ul>

<h2 id="탄생배경-1-2011년-facebook은-점점-복잡해지고-있었다">[탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.</h2>

<p>15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다.</p>

<p>문제는 기능과 팀원이 늘어날수록, 기능간의 영향을 주고받는 내용이 많아졌다는 것이다. 특히, 하나의 기능을 수정하면 예상치 못한 다른 부분이 깨지고, 깨진부분을 이해하고 수정하는 데 많은 비용이 들었다. 비용의 증가는 신기능 출시 및 개선 속도에도 영향을 미치기 시작했다.</p>

<p><img src="/assets/post_images/2026-02-25/facebook.png" alt="페이스북, 2004년(좌)&amp; 2011년(우)" /><br />
좌 : 2004년 페이스북 | 우 : 2011년 페이스북<br />
출처 : <a href="https://www.cnet.com/pictures/facebook-then-and-now-pictures/">CNET</a></p>

<p>이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식이 필요하게 된 것이다.</p>

<p>이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크 React.js가 탄생하게 된다.</p>

<h2 id="탄생배경-2-그렇다면-니즈가-생기게-된-원인은-무엇이었을까">[탄생배경 2] 그렇다면 니즈가 생기게 된 원인은 무엇이었을까?</h2>

<p>facebook은 MVC 스타일 구조와 양방향/단방향 데이터 흐름 패턴을 많이 사용하고 있었다. 이 방식은 초기화면처럼 단순할 때, 잘 동작했었다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc12.png" alt="mvc패턴" /><br />
출처 : 본인</p>

<p>그러나 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다. 그 한계는 앞서 말했던 ‘기능간의 영향을 주고 받는 내용이 많아진 점’, 그리고 이러한 내용이 대량으로 발생하면서 연쇄적인 업데이트(cascading updates)가 폭증하게 된 것이다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc3.png" alt="mvc패턴" /><br />
출처 : 본인</p>

<p>핵심은 이런 ‘예측불가 패턴’이 ‘여러 기능에서 동시에 발생’하여, ‘어디서 전파되고 어디로 재전파 되는지’를 알 수 없게 되는 현상이 연쇄적인 업데이트(cascading updates)인 것이다.</p>

<p>물론, 기능이 적은 상태에서는 많은 데이터를 관리하지 않았기 때문에 추적이 가능했을 것이다. 하지만 점차 이러한 패턴이 폭증하게 되었고 이는 개발 및 유지보수의 니즈로서 구체화 되기 시작했다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc.png" alt="페이스북의 복잡해진 MVC패턴" />
-&gt; 기능(Action) 하나를 기준으로 했을때의 cascading update의 모습 | 이때도 찾기가 어렵다.
-&gt; 기능(Action) 하나가 아닌 여러개가 동시에 움직이면? 갱신되는 Modle 값이 추적이 불가하다.
출처 : <a href="https://www.infoq.com/news/2014/05/facebook-mvc-flux/">InfoQ</a></p>

<h2 id="사례와-해결책-안-읽은-메시지-기능과-flux-패턴">[사례와 해결책] ‘안 읽은 메시지 기능’과 ‘Flux 패턴’</h2>

<p>그렇다면 그 사례는 어떤 것이 있을까? 페이스북에서는 “실제로 새 메시지가 없는데도, 새 메시지가 있다고 사용자에게 알리는 채팅버그”가 있었다. 이는 앞서 말한 “연쇄적인 업데이트 내용이 폭증”하면서, 모델에 수시로 값이 갱신되고, 어느 부분에서 값이 바뀌었는지 알 수 없었기에 생긴 버그였다.</p>

<p>그리고 이를 해결하고자 했던 패턴이 Flux 패턴이였다.</p>

<p><img src="/assets/post_images/2026-02-25/flux.png" alt="flux 패턴" /><br />
출처 : <a href="https://facebookarchive.github.io/flux/docs/in-depth-overview/">InfoQ</a></p>

<p>처음 본다면, 헷갈릴 수 있는데 핵심만 말하자면 아래와 같다.</p>

<ol>
  <li>핵심은 Store에 저장되는 ‘기능별 상태정보’ 이다.</li>
  <li>연쇄적인 업데이트가 많아지면… 어느 Model에서 값이 변경 되었는지 알 수 없었다.</li>
  <li>이를 해결해 주는게 dispatcher과 Store(정해진 도메인들이 모인 Model영역)이다.</li>
  <li>dispatcher는 액션을 모든 Store에 전달하는 단일통로이다.</li>
  <li>dispatcher는 한 액션이 처리되는 동안 상태변경이 단 한번의 path로만 일어나도록 강제한다.</li>
  <li>“안 읽은 메시지”,”채팅 목록”등의 관련 기능은 모두 Store에서 값을 읽기 때문에, 값이 헷갈리지 않게 된다.</li>
  <li>예시 이미지에서는 Store 하나로 고정되어 있지만, 이전 MVC패턴에서는 관련 없는 모델로 값이 튀는 것이 문제였다.</li>
</ol>

<p>이렇게 보면, Flux는 “View/Model이 어디서 끝나는지 모르는 스파게티 흐름”을 
단방향으로 고정하고, 최종책임을 Store에서 확인 할 수 있는 구조가 되는 것이다.</p>

<p><img src="/assets/post_images/2026-02-25/mvc4.png" alt="mvc패턴" /></p>

<p>이는 ‘고정된 경로’랑 ‘저장장소’를 제공하여, 어디서 어떤 상태가 바뀌는지 추적을 쉽게 할 수 있게 해준다. 또한 하나의 액션이 발생하면, 관련된 Store들이 각자 상태를 갱신할 수 있겠지만, 이 모든 과정은 항상 Action -&gt; Dispatcher -&gt; Store -&gt; View 라는 단방향 흐름 안에서 일어나기 때문에, 기존의 “예상치 못한 곳에서 값이 튀는” 현상을 크게 줄일 수 있는 것이다.</p>

<h2 id="엔진과-개념-react는-어떻게-진화해왔을까">[엔진과 개념] React는 어떻게 진화해왔을까?</h2>
<p>앞부분에서 페이스북이 복잡해지면서 Flux 패턴이 등장한 이야기를 했었다. 이제부터는 그 흐름이 실제 React 코드와 엔진에서 어떻게 드러나는지, 최대한 설명해보고자 한다. 설명해보가자 하는 내용은 아래와 같다.</p>

<ol>
  <li>처음에는 Class 컴포넌트로 시작했고</li>
  <li>이후에 함수컴포넌트 + Hooks로 패러다임이 바뀌었고</li>
  <li>내부 엔진은 Fiber라는 구조로 완전히 갈아엎어졌고</li>
  <li>최근에는 동시성 랜더링 개념까지 얹혀지게 되었다.</li>
</ol>

<p>이러한 모든걸 한번에 접하다보니, 초보입장에서는 당연히 부담스럽게 느껴질 수 밖에 없다. 그럼 이러한 개념을 동시에 보지말고, 하나씩 파보자.</p>

<h3 id="1-class컴포넌트---모든-걸-한-클래스-안에-넣던-시절">1. Class컴포넌트 - “모든 걸 한 클래스 안에 넣던 시절”</h3>

<p>React 초창기에는 컴포넌트를 클래스로 만들었다. 왜냐하면 초기의 React는 “상태와 로직을 품은 UI조각”을 표현하려고 했었고, 그 시점에서 가장 현실적인 도구가 클래스였기 때문이다. 당시 JS를 통해 인터렉션을 개발하는 개발자들은 물론이고 React팀에서도 개발단위의 기본을 Class라고 생각했었다. 그러나 이러한 내용은 예상과 다르게 Class단위 기능이 아닌 function단위 기능으로만 쓰게 되는데… 이 부분은 function 패러다임으로 바뀌는 다음 내용에서 언급하도록 하겠다.</p>

<p>어쨌든 본론으로 돌아와서 ‘클래스 컴포넌트’의 내용은 아래와 같다.</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

  <span class="kd">class</span> <span class="nx">Hello</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="p">{</span>
    <span class="nx">render</span><span class="p">(){</span>
      <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>안녕하세요, <span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">name</span><span class="si">}</span>님!<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="c1">// &lt;Hello name="현우"&gt;</span>
<span class="c1">// return값 : &lt;div&gt; 안녕하세요, 현우님! &lt;/div&gt;</span>
</code></pre></div></div>
<ul>
  <li>Hello 라는 클래스를 만들고</li>
  <li>React.Component를 상속받고</li>
  <li>render() 메서드에서 JSX를 반환하여, 출력값을 리턴해준다.</li>
</ul>

<p>그렇다면, 상태(state)를 가지는 클래스 컴포넌트 형태는 어땠을까?</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">React</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">class</span> <span class="nx">Counter</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="nx">construcor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>
    <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
    <span class="c1">// 컴포넌트의 초기 상태</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span><span class="na">count</span><span class="p">:</span><span class="mi">0</span><span class="p">};</span>
  <span class="p">}</span>

  <span class="nx">handleClick</span><span class="o">=</span><span class="p">()</span><span class="o">=&gt;</span><span class="p">{</span>
    <span class="c1">// 상태를 바꿀때 setState를 사용</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="na">count</span><span class="p">:</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="nx">render</span><span class="p">(){</span>
    <span class="k">return</span><span class="p">(</span>
      <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
        클릭 수:<span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span>
      <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
    <span class="p">)</span>
  <span class="p">}</span>

<span class="p">}</span>
</code></pre></div></div>

<p>여기서의 포인트는 this.state 에 상태를 넣고, this.setState() 로만 상태를 바꾼다는 점이다.
이게 기본적으로는 한눈에 들어와서 문제가 안될 것 같지만… 라이프 사이클까지 섞은 실서비스가 되면 아래처럼 더욱 복잡해진다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="kd">class</span> <span class="nx">Counter</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span><span class="p">{</span>
    <span class="kd">constructor</span><span class="p">(</span><span class="nx">props</span><span class="p">){</span>
      <span class="k">super</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
      <span class="c1">// 이벤트 핸들러로 상태 갱신</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">state</span> <span class="o">=</span> <span class="p">{</span><span class="na">count</span><span class="p">:</span><span class="mi">0</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="nx">componentDidMount</span><span class="p">(){</span>
      <span class="c1">// 라이프사이클 1</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">컴포넌트가 화면에 등장</span><span class="dl">'</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">componentDidUpdate</span><span class="p">(</span><span class="nx">prevProps</span><span class="p">,</span> <span class="nx">prevState</span><span class="p">){</span>
      <span class="c1">// 라이프 사이클 2</span>
      <span class="k">if</span><span class="p">(</span><span class="nx">prevState</span><span class="p">.</span><span class="nx">count</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">)}{</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">count가 바뀜:</span><span class="dl">'</span><span class="p">,</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="nx">componentWillUnmount</span><span class="p">(){</span>
      <span class="c1">// 라이프 사이클 3</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">컴포넌트가 화면에서 사라짐</span><span class="dl">'</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">handleClick</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="c1">// 이벤트 핸들러</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span><span class="na">count</span><span class="p">:</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="nx">render</span><span class="p">(){</span>
      <span class="k">return</span><span class="p">(</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">handleClick</span><span class="si">}</span><span class="p">&gt;</span>
          클릭 수:<span class="si">{</span><span class="k">this</span><span class="p">.</span><span class="nx">state</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span>
        <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
</code></pre></div></div>

<p>즉, 상태관련 코드가 constructor, 라이프사이클 메서드들(1,2,3), 이벤트핸들러로 산개된다.<br />
기능이 많아질수록 하나의 클래스 파일이 점점 비대해진다는 것이다. 그래서 유지보수를 하면서 이러한 피로감이 증대하게 되는 것이 문제점이였다. 이를 React팀에서 다시 생각하기 사작한 것이다.</p>

<h3 id="2-함수-컴포넌트와-hooks---어쨌든-ui는-그냥-함수잖아">2. 함수 컴포넌트와 Hooks - ‘어쨌든 UI는 그냥 함수잖아?’</h3>
<p>React 팀이 다시 생각한 포인트는 이것이다.</p>

<p>“UI는 결국 state -&gt; UI로 매핑되어 바뀌는 함수 아닌가?”<br />
생각해보자. 굳이 클래스 형태가 아니더라도 바뀌는 단위는 클래스가 아니라 함수 아니였나?
그럼 함수단위로 최소한 쪼개보자. 어떠한가?</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">hello</span><span class="p">({</span><span class="nx">name</span><span class="p">}){</span>
  <span class="k">return</span> <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span> 안녕하세요, <span class="si">{</span><span class="nx">name</span><span class="si">}</span>님!<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;;</span>
<span class="p">}</span>

<span class="c1">// &lt;hello name="현우"&gt;</span>
<span class="c1">// retrun값 : 안녕하세요, 현우님!</span>
</code></pre></div></div>

<ul>
  <li>입력 : props</li>
  <li>출력 : JSX</li>
</ul>

<p>이렇게 보면 직관적이고 한눈에 들어오게 된다.</p>

<h3 id="3-hook이-없던-시절의-한계">3. Hook이 없던 시절의 한계</h3>
<p>그러나 초창기에는 함수 컴포넌트가 상태나 라이프사이클을 가질 수 없었다. Class단위로 설계가 되었기 때문이다. 그래서 상태나 생명주기가 필요해지는 순간(기능이 복잡해 지는 순간)에는 그 부분은 클래스 컴포넌트로 구현해야 했다.</p>

<p>당시의 함수 컴포넌트 아래의 용도로 쓰였었다.</p>
<ul>
  <li>함수 컴포넌트 : 단순표시용</li>
  <li>상태/라이프사이클 필요시 : 클래스 컴포넌트</li>
</ul>

<p>이러한 이중 구조가 점점 거슬리기 시작했고, “함수에서도 상태를 쓰고 싶다”는 니즈가 점점 커지게 되었다.</p>

<h3 id="4-hook의-등장---함수에-상태와-생명주기를-심어주기">4. Hook의 등장 - 함수에 “상태와 생명주기”를 심어주기</h3>
<p>그래서 나온 것이 Hook이다.
Hook은 “함수 컴포넌트 안에서 React 기능을 쓸 수 있게 해주는 함수”라고 생각하면 된다.</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span><span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span><span class="p">}</span><span class="k">from</span> <span class="dl">'</span><span class="s1">react</span><span class="dl">'</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Counter</span><span class="p">(){</span>
  <span class="c1">//count라는 상태값과 그걸 바꾸는 setCount함수를 만든다.</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">count</span><span class="p">,</span> <span class="nx">setCount</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">//count가 바뀔 때마다 콘솔에 로그를 남긴다.</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">현재 count:</span><span class="dl">'</span><span class="p">,</span><span class="nx">count</span><span class="p">);</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">count</span><span class="p">]);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="p">()</span><span class="o">=&gt;</span><span class="nx">setCount</span><span class="p">(</span><span class="nx">count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="p">&gt;</span>
      클릭수:<span class="si">{</span><span class="nx">count</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>여기서 포인트는</p>
<ul>
  <li>useState(0) : 초기값 0으로 상태 슬롯 하나 생성</li>
  <li>useEffect(… , [count]) : useEffect가 실행되면,그리고 count콜백이 바뀔 때마다 실행되는 “후처리 작동” 등록</li>
</ul>

<p>결론적으로 클래스에서 여기저기 산개된 것들이, 하나의 함수 안으로 모여 들어온 느낌이다.</p>

<p>하지만 대가도 있다.</p>
<ul>
  <li>Hook은 항상 컴포넌트 최상단에서, 매 랜더링마다 같은 순서로 호출되어야 한다.(if,while등과 같은 조건문 안에 작성금지!)</li>
  <li>랜더링이 다시 일어날 때마다 이 함수가 통째로 다시 실행된다는 점을 이해해야 한다.</li>
  <li>useEffect의 실행시점, 의존성 배열등을 이해하지 않으면 이상한 버그를 만나기 쉽다.(최소조건의 구조로 작성해야함)</li>
</ul>

<p>그래서 문법 자체는 직관적으로 변했는데, “작동 원리까지 같이 이해해야 하는” 새로운 난이도가 생긴 것이다.
상기의 세개의 부분은 중요하지만…다음 글에서 차후 다뤄보기로 하겠다. 현재는 “학습커브가 왜 가파른지”에 대해 언급하는 내용이기에 문맥을 해칠수 있어서 건너뛰는 것이다. 분명한것은 Vanila JS인 경우 수학적으로 딱딱 떨어지는 분자단위의 논리와 같다면, react와 같은 프레임워크는 프로토콜같은 추상단위의 개념으로 봐야 이해하기 용이하다는 것이다. 간단히 얘기하자면, 논리의 앞뒤가 맞기 이전에 의도가 무엇인지 부터 파악해야 한다는 것이다. 그 뒤에 안의 논리를 분자단위로 쪼개도 이해는 늦지 않다.</p>

<h3 id="3-fiber-엔진---랜더링을-잘게-쪼개서-처리하자">3. Fiber 엔진 - “랜더링을 잘게 쪼개서 처리하자”</h3>

<p>…작성중…</p>]]></content><author><name></name></author><category term="React.js" /><summary type="html"><![CDATA[React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다.]]></summary></entry><entry><title type="html">[JavaScript] var, let, const는 왜 생겨났을까?</title><link href="https://hwp-log.github.io/javascript/2026/02/20/JS-day-1.html" rel="alternate" type="text/html" title="[JavaScript] var, let, const는 왜 생겨났을까?" /><published>2026-02-20T00:00:00+00:00</published><updated>2026-02-20T00:00:00+00:00</updated><id>https://hwp-log.github.io/javascript/2026/02/20/JS-day-1</id><content type="html" xml:base="https://hwp-log.github.io/javascript/2026/02/20/JS-day-1.html"><![CDATA[<p>코딩 학습의 자연스러운 동기는 무엇일까? <a href="https://hwp-log.github.io/reflection/2026/02/19/reflection-1.html">이전 글</a>에서 고민해본 결과, 그 동기는 ‘무언가 만들고자 하는 마음’과 ‘작동 원리에 대한 궁금증’ 두 가지로 나뉜다는 결론에 도달했다. 이번 글에서는 후자 - ‘var의 작동 원리에 대한 궁금증’부터 let, const가 왜 생겨났는지에 대한 궁금증과 학습으로 이어진 과정까지 작성 해 보려 한다.</p>

<h2 id="var-let-const는-왜-생겨났을까-라는-의문">“var, let, const는 왜 생겨났을까?” 라는 의문</h2>
<p>JS를 처음 배우면서 떠오르는 의문점이 뭐가 있을까? 바로 ‘var와 호이스팅’이라는 개념이라고 생각한다. 왜냐하면 함수랑 블록, 스코프 개념이 정립되지 않은 상태이기 때문이다. 특히 이를 코드로 쳐보지 않는 이상 누구든지 난해한 부분이다.</p>

<p>어쨌든 var에 대한 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/var">공식문서</a> 내용을 보면, 아래와 같이 설명하고 있다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="c1">// Expected output: 2</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="c1">// Expected output: 2</span>
</code></pre></div></div>

<p>‘변수를 선언, 선택적으로 초기화할 수 있습니다.’ 알아듣기 어려운 추상적 개념이였다. 어떻게 이해를 해야 할까? 가정을 해보자. 코드는 기본적으로 절차지향으로 처리한다. 간단히 얘기해서 위에서 아래로 읽어 나간다는 것이다. 그렇다면 if문 블록의 var x = 2로 재선언 되었기에, 다른 주소값을 참조하는 다른 x일까? 근데 왜 if블록의 재선언 값이 전역의 x변수 값으로 출력되는 걸까?</p>

<p>이에 대한 의문이 더 이상 풀리지 않아서 검색을 해 보았다. 그리고 이에 관한 내용정리는 총 2가지로 나뉜다.</p>

<p>첫번째, ‘var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.’ 의 예시는 설명에 맞지 않는 예시이다.  <br />
두번째, var는 블록안에서의 재선언 값이 전역값에 영향을 준다.</p>

<p>이 두 가지 내용을 하나씩 풀어보자.</p>

<h2 id="첫번째-var-문은-변수를-선언하고-선택적으로-초기화할-수-있습니다-의-예시는-설명에-맞지-않는-예시이다">첫번째, ‘var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.’ 의 예시는 설명에 맞지 않는 예시이다.</h2>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// var 선택적 초기화 가능</span>
<span class="kd">var</span> <span class="nx">x</span><span class="p">;</span> <span class="c1">// (선언 + 초기화 안함) -&gt; undefined</span>
<span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span><span class="mi">10</span><span class="p">;</span> <span class="c1">// (선언 + 초기화 함) -&gt; 10</span>

<span class="c1">// let 선택적 초기화 가능</span>
<span class="kd">let</span> <span class="nx">a</span><span class="p">;</span> <span class="c1">//가능</span>

<span class="c1">// const 선택적 초기화 불가</span>
<span class="kd">const</span> <span class="nx">b</span><span class="p">;</span> <span class="c1">// 에러! const는 반드시 초기화해야 함.</span>
</code></pre></div></div>

<p>위의 예시는 검색을 통해 정리해 본 내용이다. 내용을 보면 결국 선택적으로 초기화 한다는 것은, 변수선언시 ‘초기값을 넣을지 말지를 자유롭게 지정할 수 있다는 뜻’이였다. 그렇다면 아까 봤던 첫번째 예시는 이런 특징들이 보일까?</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="c1">// Expected output: 2</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="c1">// Expected output: 2</span>
</code></pre></div></div>

<p>그렇지 않았다. 오히려 블록 스코프에서 선언한 값이 전역변수에 영향을 미친다는 것만 확인이 가능했던 예시였다. 따라서 해당 예시는 var의 특성을 보여주려다가 생긴 설명에 맞지 않는 예시라고 생각한다.</p>

<h2 id="두번째-var는-블록안에서의-재선언-값이-전역값에-영향을-준다">두번째, var는 블록안에서의 재선언 값이 전역값에 영향을 준다.</h2>

<p>그렇다면 아까 의문이 생겼던, 예시는 어떠한가? 다른 블록에서 선언했으니 당연히 다른 변수일 거라고 생각하겠지만, 결론적으로 말하자면, var는 JS가 처음 만들어질 때, 함수 스코프를 갖고 있었기 때문에 if 블록을 벗어날 수 있게 된 것이다.</p>

<p>??????</p>

<p>JS를 처음 배웠을 때의 내 ‘머릿속에 지울 수 없던 혼란’이 이것 이였다. 그러나 var가 이러한 작동을 하게 된 이유는 조금 뒤에 다뤄보기로 하며, 이 말도 안 되는 선언 키워드의 작동원리에 대해 더욱 집중해 보도록 하자.</p>

<p>기본적으로 블록이라는 개념을 익힌 개발자라면, if문이라는 블록에서 var x = 2는 생명주기를 다했기 때문에, 전역변수에 영향을 미치지 않는다고 생각한다. 하지만, var는 함수 스코프를 구현하기 위해 호이스팅이라는 메커니즘을 넣게 되었고, 영향을 미칠 수 있게 된 것이다. 그렇다면 호이스팅의 메커니즘이 적용되는 JS 엔진의 관점에서 코드를 해석 해보자.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 원본</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="c1">// Expected output: 2</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="c1">// Expected output: 2</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 원본 내용을 JS엔진의 관점에서 호이스팅 후 코드 해석</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="kc">undefined</span> <span class="c1">// 호이스팅된 x</span>
<span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// x는 1로 재할당</span>

<span class="k">if</span> <span class="p">(</span><span class="nx">x</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">x</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 호이스팅 된 전역 변수 x는 2로 재할당</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
  <span class="c1">// Expected output: 2 // 그래서 x는 최종적으로 2를 출력</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span>
<span class="c1">// Expected output: 2 // 이미 호이스팅 된 전역변수 x는 2이기에 2를 출력</span>
</code></pre></div></div>

<p>즉, 다른 변수일 거라고 기대했던 if 블록 안의 x가 JS엔진의 관점에서는 처음부터 같은 x였고, 그 안에서의 할당이 그대로 바깥에 영향을 미친다는 것이다. 이것이 var의 스코프를 함수 단위로 이해해야 하는 이유다.</p>

<p><img src="/assets/post_images/2026-02-20/image.png" alt="호이스팅 밈" /><br />
(자바스크립트 엔진이란 건, 그냥 단순하게 코드 줄을 이리저리 옮기는 정도로 돌아가는 게 아니다!)</p>

<h2 id="var는-왜-이렇게-설계되었을까">var는 왜 이렇게 설계되었을까?</h2>

<p>이 의문을 풀기 위해서는 JS가 태어난 배경을 먼저 살펴야 한다. 1995년 대략 30년전, Netscape라는 웹 브라우저라는 것이 존재했으며, Brendan Eich라는 개발자는 Netscape의 요청에 의해 인터랙티브한 기능을 넣고자 언어를 제작하게 된다. 이것이 JS의 시작이였다. 중요한 것은 이때 당시의 인터랙션(상호작용)에 대한 개념의 인식이였는데, 전화번호나 우편번호가 제대로 입력됐는지 확인하는 기능 또는 오디오를 재생하는 기능 정도의 간단한 내용이였다. 아래는 Brendan Eich의 개인 홈페이지이다. 당시의 웹의 수준을 엿볼 수 있다.</p>

<p><img src="/assets/post_images/2026-02-20/image1.png" alt="Brendans Web World" />
-&gt; https://web.archive.org/web/19981207072942/people.netscape.com/brendan/<br />
당시의 홈페이지가 아직도 남아있다.</p>

<p>즉, 애당초 복잡한 어플리케이션을 만들 언어가 아니었다. 간단한 웹 인터랙션용 스크립트 언어에 블록 스코프까지 설계할 여유가 없었고, 함수 단위로만 변수를 관리하면 충분했다. 또한 10일이라는 시간 안에 넣을 수 있는 것도 이 정도가 한계였을 것이다.</p>

<p>이것이 var가 함수 스코프로 설계된 배경이다. 잘못 만든 것이 아니라, 당시 상황에서는 합리적인 선택이였다. 문제는 JS가 예상과 달리 웹의 핵심 언어로 성장하면서, 이 단순한 설계가 한계를 드러내기 시작한 것이다.</p>

<p>출처:<a href="https://cybercultural.com/p/1995-the-birth-of-javascript/">Cybercultural: 1995: The Birth of JavaScript</a></p>

<h2 id="letconst가-없던-시절의-처리법">let/const가 없던 시절의 처리법</h2>

<p>var의 함수 스코프 문제를 개발자들이 몰랐던 것은 아니다. 웹이 점점 복잡해지면서 변수 충돌 문제가 실제로 발생하기 시작했고, 이를 해결하기 위한 패턴이 등장했다. 바로 IIFE(즉시 실행 함수 표현식)이다.</p>

<p>형태 : (function() { … })()</p>

<p>예시코드는 아래와 같다.</p>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">(</span><span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
        <span class="kd">var</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// var는 함수스코프 이므로 갇힘</span>
    <span class="p">}</span>
<span class="p">})();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// count는 전역의 var를 출력. 따라서 0을 출력!</span>
</code></pre></div></div>

<p>만약, 블록 스코프가 존재했다면 어땠을까?</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// count는 전역의 let을 출력. 따라서 0을 출력!</span>
</code></pre></div></div>

<p>이 처럼 var의 한계를 우회하기 위한 패턴이 존재했지만, 근본적인 해결책은 아니었다. 언어 자체가 바뀌어야 했다.</p>

<h2 id="let과-const의-등장---es6">let과 const의 등장 - ES6</h2>

<p>이후 2015년, ECMAScript6 (ES6)가 발표되면서 드디어 let과 const가 등장했다. var만으로 20년을 버텨온 JS에 드디어 블록 스코프 및 재할당 방지를 막아줄 선언방식이 새로 등장한 것이다.</p>

<h3 id="1-새로운-선언-방식에-블록-스코프-도입">1. 새로운 선언 방식에 블록 스코프 도입</h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// let은 블록 스코프이다. 따라서 if블록 안에서 생명주기를 다함</span>
<span class="p">}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="c1">// 참조 에러!!</span>
</code></pre></div></div>

<h3 id="2-tdz임시-사각지대">2. TDZ(임시 사각지대)</h3>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">);</span> <span class="c1">// undefined — 에러 없이 조용히 넘어감</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">);</span> <span class="c1">// ReferenceError — 선언 전 접근 불가</span>
<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//JS엔진 관점</span>
<span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 호이스팅: 선언 + undefined로 초기화</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span> <span class="c1">// undefined — 에러 없이 조용히 넘어감</span>
<span class="nx">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="kd">let</span> <span class="nx">y</span><span class="p">;</span> <span class="c1">// 호이스팅 : 선언 + 초기화 유보 (TDZ 구간)</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">y</span><span class="p">)</span> <span class="c1">// ReferenceError: y가 초기화 되기전에는 값에 접근할 수 없습니다.</span>
<span class="nx">y</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
</code></pre></div></div>

<h3 id="3-const---재할당-방지">3. const - 재할당 방지</h3>
<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">API_URL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://first_api.com</span><span class="dl">"</span>
<span class="nx">API_URL</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">https://second_api.com</span><span class="dl">"</span> <span class="c1">// TypeError — const는 재할당 불가</span>
</code></pre></div></div>

<p>변하지 말아야 할 값을 const선언을 통해 값의 변화를 막아준다.</p>

<h2 id="var-let-const-실제-응용">var, let, const 실제 응용</h2>

<p>그렇다면 실제 응용 사례에서는 어떻게 출력될까?
아래의 예시로 연습을 해 봤다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">A:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">B:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">C:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">D:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
    <span class="p">}</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">E:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">F:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">G:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">H:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span>
</code></pre></div></div>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// JS 엔진관점</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> 
<span class="kd">let</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="c1">// 20;</span>

<span class="kd">function</span> <span class="nx">outer</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// 10;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">A:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// var a가 if문 블록에 있음으로, 호이스팅 되어 undefined를 형성한다.</span>
    <span class="nx">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">B:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 재할당 되어 전역 변수 2가 20이 된다.</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">b</span><span class="p">;</span> <span class="c1">// 호이스팅 된 b;</span>
        <span class="nx">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="nx">b</span> <span class="o">=</span> <span class="mi">200</span><span class="p">;</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">C:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 재할당 되어, 호이스팅 된 a가 10으로 출력됨.</span>
        <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">D:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 재선언 되어, 호이스팅 된 b가 200으로 출력됨.</span>
    <span class="p">}</span>
    
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">E:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// outer함수 안의 a가 10으로 할당되어 있기 때문에 10으로 출력됨.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">F:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 스코프 체이닝으로 전역변수 b로 올라감. b는 20으로 바뀌어 있음. 따라서 20으로 출력됨.</span>
<span class="p">}</span>

<span class="nx">outer</span><span class="p">();</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">G:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">);</span> <span class="c1">// 전역변수 a =1임</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">H:</span><span class="dl">"</span><span class="p">,</span> <span class="nx">b</span><span class="p">);</span> <span class="c1">// 전역변수 b =20임</span>
</code></pre></div></div>

<h2 id="결론">결론</h2>

<p>“var, let, const는 왜 생겨났을까?”</p>

<p>이 질문에 대한 답은 결국에 JS의 변천사 자체가 답이였다. Netscape가 탄생했을때, JS의 단순함은 쓰기 편안한 언어 였을 것이다. 그러나 var의 함수 스코프가 한계를 드러냈고, 개발자들은 IIFE라는 우회 패턴으로 버텨야 했다. 그리고 2015년, ES6의 let, const의 등장으로 블록 스코프, TDZ, 재할당 방지라는 근본적인 해결책이 마련되었다.</p>

<p>결국 이 세 선언방식의 탄생은 “완벽한 언어의 설계가 아닌, 시대에 맞게 변화해온 언어의 변화 과정”이였다. 이 과정을 직접 겪어보고 생각한 것이, 단순히 ‘var를 쓰지마세요’가 아닌, 다른 차원의 이해를 만들어 주었다고 생각한다.</p>]]></content><author><name></name></author><category term="JavaScript" /><summary type="html"><![CDATA[코딩 학습의 자연스러운 동기는 무엇일까? 이전 글에서 고민해본 결과, 그 동기는 ‘무언가 만들고자 하는 마음’과 ‘작동 원리에 대한 궁금증’ 두 가지로 나뉜다는 결론에 도달했다. 이번 글에서는 후자 - ‘var의 작동 원리에 대한 궁금증’부터 let, const가 왜 생겨났는지에 대한 궁금증과 학습으로 이어진 과정까지 작성 해 보려 한다.]]></summary></entry><entry><title type="html">[Reflection] 프로그래밍 학습에 왜(Why)를 묻기 시작하면서 달라진 것들</title><link href="https://hwp-log.github.io/reflection/2026/02/19/reflection-1.html" rel="alternate" type="text/html" title="[Reflection] 프로그래밍 학습에 왜(Why)를 묻기 시작하면서 달라진 것들" /><published>2026-02-19T00:00:00+00:00</published><updated>2026-02-19T00:00:00+00:00</updated><id>https://hwp-log.github.io/reflection/2026/02/19/reflection-1</id><content type="html" xml:base="https://hwp-log.github.io/reflection/2026/02/19/reflection-1.html"><![CDATA[<p>현재, Next.js를 사용한, x.com을 작성한 시점에서 의문이 한가지 든 점이 있었다. 과연 개발공부라는 것이 다른사람이 제시한 커리큘럼대로 공부하는 것이 맞는지에 대한 의문이다. 물론 무엇이 맞고 틀리고의 문제가 아니였다. 처음 개발공부를 시작했을때는 기초적인 추상성과 그것을 구현하는 기본기에 숙달되기 위해 공부한 거였다면, 이번에 공부하는 관점은 조금 바꿀필요가 있다고 생각했다.</p>

<p>사실, 클론코딩을 듣고 배울때 좋은점은 시니어 개발자의 ‘인사이트’와 지식의 ‘학습시간의 효율’ 이였다. 확실히, 들을때 느낀 점은 “아 저 기술은 저렇게 응용이 될 수 있구나” 그리고 “오늘은 커리큘럼에서 이정도 공부했구나라는 안도감” 이였다. 그러나 중간세션까지 공부하면서 느낀점은 “이것이 내가 의무감에 의해서 듣고 있는거 아닌가?” 라는 생각이 반복적으로 들었다. 특히 멘토분과 얘기를 하면서 느낀 것이 그 생각을 촉발한 계기인데, 얘기는 다음과 같다.</p>

<p>나 : “..해서 x.com의 클론코딩 수업을 통해 이번주는 패러렐 라우팅 &amp; 인터셉터 라우팅의 개념을 배웠습니다.”<br />
맨토 : “좋습니다. 근데 x.com에서 저 기능은 왜 썼을가요?”<br />
나 : “아 그게.. x.com에서는 SPA(Sigle Page Application)원칙을 고수하다보니깐 그런거 아닐까요?”<br />
나 : “특히나 SNS처럼 많은 내용을 담고 있는 웹 어플리케이션은 UX(사용자 경험)관점에서 SPA가 적합하다고 생각되기에…?”<br />
나 : “로그인 페이지에서도 SPA원칙을 지키기 위해 패러레 라우팅 &amp; 인터셉터 라우팅을 썼다고 생각합니다만..”<br />
멘토 : “그래요? 근데 로그인은 굳이 한페이지 안에서 패러렐 라우팅 &amp; 인터셉터 라우팅을 사용하여, 모달팝업을 띄울 필요가 있을까요?”<br />
나 : “??”<br />
멘토 : “물론 그 페이지에서 보안정보를 담고 있거나 처리하는 부분이 많다면 모달팝업을 띄워서 로그인 처리하면 된다고 생각합니다만, 이건 추측이구요.”<br />
멘토 : “중요한 것은 학습강의에서 그 부분에 대한 언급이나 설명이 있었는지 궁금하다는 것이죠.”<br />
나 : “아.. 하기사 카카오톡이나 네이버 구글같은곳도 SPA처럼 처리하는 것이 아닌, 로그인 페이지로 이동해서 처리를 하죠?”</p>

<p>… 중략 …</p>

<p>여기서 핵심은 무엇일까? 개인적인 견해는 다음과 같다. 무엇이 답이라기 보다는…“해당 웹 어플리케이션에서 사용되는 아키텍처링이 적합한지?”, “그리고 더 나은 기술과 이유가 있는지?”에 대한 의문이 핵심이라는 것이다.</p>

<p>방금전, 클론코딩이 이점이 뭐라고 언급하였는가? ‘인사이트’와 ‘학습시간 효율’이였다. 그러나 바꿔 말하면 이 두가지를 얻는 동시에 ‘능동적인 태도’와 ‘아키텍처링 사고력’이 떨어지는 것을 느끼게 되었다.</p>

<p>‘맞다, 틀렸다’ 같은 이분법적인 사고보다는 ‘적합한가?’, ‘더 나은방식과 이유가 명확한가?’ 라는 의문은 결국 자발적인 학습과 시야를 확장 시켜준다고 생각한다. 왜냐하면, 지금 이 글을 쓰게 된 계기도 프로그래밍 학습에 대한 사고전환이 있었기 때문이다.</p>

<p>이때 문득, “새로운 프로그래밍 언어를 배우는 유일한 방법은 그 언어로 프로그램을 직접 작성하는 것입니다.” 라는 말이 떠오르게 되는데, 이 말을 누가 했는지 찾다가 C언어를 개발한 데니스 리치를 검색하게 된다.</p>

<h2 id="능동적-학습과-아키텍처링-사고">능동적 학습과 아키텍처링 사고</h2>

<p>실제로 그가 한 말인지에 대한 출처는 불분명하지만, 중요한 것은 ‘남들이 다해서’라는 의무적인 의식이 아닌, ‘이게 뭐지?’, ‘어? 아 이거 좀 알아봐야 겠는데?’ 라는 ‘자연스러운 의문’과 ‘필요성’이 떠올라야 한다는 것이다. 이것이 곧 ‘배우고자 하는 의지’로 변환되고 다시 이것이 곧 ‘아키텍처링 사고’와 ‘능동적인 태도’로 이어진다는 것이다.</p>

<p>(이게뭐지?, 어?) -&gt; (좀 알아봐야 겠는데?) -&gt;(배워야 겠다) -&gt; (아 이래서?) -&gt; (아키텍처링 사고) -&gt; (이게 뭐지?, 어?) -&gt; (.. 무한 반복 ..)</p>

<h2 id="데니스-리치의-사례">데니스 리치의 사례</h2>
<p><img src="/assets/post_images/2026-02-19/image0.png" alt="데니스 리치" /><br />
출처: (https://anders.unix.se/2015/10/26/interview-with-dennis-ritchie-2003/)</p>

<p><img src="/assets/post_images/2026-02-19/image1.png" alt="데니스 리치" /><br />
출처: (https://joone.net/2017/08/29/10-%EB%8D%B0%EB%8B%88%EC%8A%A4-%EB%A6%AC%EC%B9%98%EC%9D%98-%EC%9D%BC%EC%83%9D/)</p>

<p>그의 사례만 보더라도 물리학을 전공 했음에도, 컴퓨터 강연을 듣고 점점 빠지게 되고 나중에는 실용적인 영역에서 연구하고 C언어를 개발하게 된다.(B언어 개선 및 이를 기반으로 유닉스를 개발)</p>

<p>여기서 느낀점은 학습자체가 목적이 되기보다는 무언가를 하고자 할때, 거기서 오는 자연스러운 학습이 중요하다는 것이다.</p>

<h2 id="프로그래밍-학습에-대한-고찰">프로그래밍 학습에 대한 고찰</h2>

<p>그래서 이전에 처음으로 프론트엔드 엔지니어가 되고자 했을때를 떠올려본다. 처음 교양과목으로 홈페이지를 하드코딩하는 수업을 들었었고, 자신만의 웹 공간을 만든다는 것에 매력을 느껴, 이 직업을 선택하게 된 것이 작은 계기였다.</p>

<p>“더 나은 홈페이지를 만들수 있지 않을까?”라는 순수한 고민부터, 지금의 수동적인 태도로 이어지기까지 무슨문제가 있었던 것일까? 학습방식을 잘못 배운것이 문제일까? 아니면? 무엇이 되었던, 중요한 것은 이 과정을 자연스럽게 즐기고 해결 할 수 있는 끈기가 필요하지 않았을까? 멘토와 얘기를 하다보면 종종 그런생각이 들었다. 저 분은 나와 사고하는 태도가 다르구나.. 그런 태도는 어디서 나온걸까? 잘 모르겠지만, 적어도 지금 내가 무엇을 해야 할지에 대한 자세와 방향성을 알 수 있다면, 그것부터 시작하면 되지 않을까?</p>

<p>완벽주의보다는 자연스러운 동기와 거기서 목표를 향해가는 자연스러운 시행착오를 쌓아가야 할 시점이다.</p>]]></content><author><name></name></author><category term="Reflection" /><summary type="html"><![CDATA[현재, Next.js를 사용한, x.com을 작성한 시점에서 의문이 한가지 든 점이 있었다. 과연 개발공부라는 것이 다른사람이 제시한 커리큘럼대로 공부하는 것이 맞는지에 대한 의문이다. 물론 무엇이 맞고 틀리고의 문제가 아니였다. 처음 개발공부를 시작했을때는 기초적인 추상성과 그것을 구현하는 기본기에 숙달되기 위해 공부한 거였다면, 이번에 공부하는 관점은 조금 바꿀필요가 있다고 생각했다.]]></summary></entry><entry><title type="html">[Next.js] x-com의 홈 메뉴 컨텐츠 소비 기능 만들기(모달편)</title><link href="https://hwp-log.github.io/next.js/2026/02/12/next.js-session-2-23gang.html" rel="alternate" type="text/html" title="[Next.js] x-com의 홈 메뉴 컨텐츠 소비 기능 만들기(모달편)" /><published>2026-02-12T00:00:00+00:00</published><updated>2026-02-12T00:00:00+00:00</updated><id>https://hwp-log.github.io/next.js/2026/02/12/next.js-session%202-23gang</id><content type="html" xml:base="https://hwp-log.github.io/next.js/2026/02/12/next.js-session-2-23gang.html"><![CDATA[<p>이번은 x.com의 홈 메뉴 컨텐츠 소비 기능을 만들어 보고자 한다.<br />
많지 않은 기능처럼 보이지만, 사용자 관점에서 필요한 기능을 쪼개본다면 몇 가지 생각해야 할 부분이 많다.</p>

<p>첫번째, 게시글 클릭 시 모달로 상세보기<br />
두번째, 좋아요 버튼을 누른 게시글의 버튼 색상이 달라지는 기능<br />
세번째, 게시글 하단의 댓글/리포스트/좋아요 버튼(상호작용 인터페이스)<br />
네번째, 새로 작성된 글을 “3분 전”이라 표시하여, SNS에서 정보의 신선도를 빠르게 파악하게 해주는 기능 등이 존재한다.</p>

<h2 id="왜-게시글-클릭시-모달로-상세보기-일까">왜? 게시글 클릭시, 모달로 상세보기 일까?</h2>
<p>x.com을 사용하다 보면, 새로운 페이지 이동이 최소화 된 것을 알 수 있다. 생각보다 많은정보를 소화하기 위한 전략이라 할 수 있는데, 이는 전통적인 방식인 MPA 패턴이 해당 어플리케이션 패턴에 최적화 되기 어렵다고 추론할 수 있다. 특히 새로고침 및 페이지 이동은 사용자 입장에 있어서 사용자의 스크롤 위치, 입력 중인 내용, 현재 보던 맥락의 유실우려가 존재하여, UX 경험을 좋지 않게 할 수 있다. 이에 대응가능한 패러다임이 SPA (Single Page application) 방식이다.</p>

<p>SPA는 새로고침 및 페이지 이동을 최소화하여, 페이지 이동 및 사용자가 정보를 습득함에 있어서 잦은 이동이 줄어 사용경험의 혼잡함을 줄여준다는 장점이 있다. 그러나 이는 많은 정보를 담은 페이지의 경우를 뜻하며, 상대적으로 적은 정보를 담은 페이지는 MPA설계가 낫다는 의견도 많다. 그렇기에 한단계 높은 수준의 설계라기보다는 상황에 맞는 설계 패턴으로 자리 잡았다고 보는게 개인의 의견이다. 이에 대한 고찰은 추후 다뤄볼 생각이다.</p>

<p>본론으로 다시 돌아와서, x.com은 이러한 SPA라는 패러다임 원칙에 맞게 로그인 부터 안쪽 컨텐츠 소비까지 철저하게 SPA로 설계되었다는 점에 초점을 맞춰야한다. 그래야 Next.js의 기술들인 패러랠 라우팅, 인터셉팅 라우팅을 통해 비슷하게 클론코딩 하려는 이유를 알 수 있게 된다. (참고로 x.com닷컴은 Next.js가 아닌 자체 프레임워크로 만들어진 사이트이다. 다만 학습목적에서 Next.js로 구현하려는 것일 뿐 이다.)</p>

<h2 id="패러랠-라우팅">패러랠 라우팅?</h2>
<p>그렇다면, 패러랠 라우팅은 무엇일까? x.com에서는 메뉴의 한 페이지에 각 영역별로 정보가 담긴다. 이 정보가 담기는 영역마다 하나의 컴포넌트가 대응한다고 생각하면 된다.</p>

<p><img src="/assets/post_images/2026-02-13/image.png" alt="패러랠 라우트" /></p>

<p>이때, 동일한 레이아웃에서 하나 이상의 페이지를 렌더링 하는 기술을 패러랠 라우팅이라 한다.</p>

<h2 id="인터셉팅-라우팅">인터셉팅 라우팅?</h2>
<p>또한 인터셉팅 라우팅은 정보가 담긴 페이지를 모달로 표시해 주기 위한 기술이다.</p>

<p><img src="/assets/post_images/2026-02-13/image1.png" alt="인터셉팅 라우트" /></p>

<p>x.com 처럼 사진을 클릭하면, 오버레이되어 사진을 모달로 표시할 수 있다. 그리고 이 경우 Next.js는 <code class="language-plaintext highlighter-rouge">/photo/123</code>경로를 가로채서 <code class="language-plaintext highlighter-rouge">/feed</code> 에 오버레이한다. 이때 주소창에는 Card.tsx경로가 표시가 안되는데, 이 기술을 인터셉팅 라우팅이라 한다.</p>

<p>-&gt; 그럼 패러랠/인터셉팅 라우팅은 Next.js에서 어떻게 구현하는 것일까?</p>

<h2 id="패러랠인터셉팅-라우팅으로-모달-구현하기">패러랠/인터셉팅 라우팅으로 모달 구현하기</h2>
<p>먼저, 모달을 소비하는 부분이 어디인지 생각해 보자. x.com을 사용해 본 유저라면 아래의 상황이 익숙할 것이다. 글 작성, 게시글 상세, 이미지 확대 등 다양한 곳에서 모달이 사용된다.
<img src="/assets/post_images/2026-02-12/image3.png" alt="이미지처럼 글 작성, 게시글 상세, 이미지 확대" /></p>

<p>기본적으로 이러한 페이지들이 모달을 사용하기 때문에, 이에 대한 default값을 설정 해줘야 한다. 방법은 의외로 간단하다. 세그먼트 별로 나뉜 폴더안에 default.tsx를 작성한뒤, 함수를 정의해주면 된다.</p>

<h2 id="폴더-구조">폴더 구조</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@modal/
├── (.)compose/                    &lt;- 인터셉팅 라우트
│   └── tweet/
│       ├── modal.module.css
│       └── page.tsx               &lt;- 글 작성 모달
│
├── [username]/
│   ├── default.tsx                &lt;- 1번 default
│   └── status/
│       └── [id]/
│           ├── default.tsx        &lt;- 2번 default
│           └── photo/
│               └── [photoId]/
│                   ├── _component/
│                   │   └── PhotoModalCloseButton.tsx
│                   ├── page.tsx   &lt;- 사진 모달
│                   └── photoModal.module.css
│
└── default.tsx                    &lt;- 3번 default
</code></pre></div></div>

<h2 id="코드-구조">코드 구조</h2>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Default</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 설정해주면, 모달을 띄우기 전에는 null값을 던져주기 때문에, 페이지 작동에도 문제가 발생하지 않는다. 다만 각 세그먼트별로 대응해야 하다보니 더미페이지가 다수 발생한다는 단점이 존재한다.(눈과 머리가 아프다.)</p>

<p>두번째, 해당 모달을 렌더링하는 페이지에서는 반드시 “use client”를 작성해줘야 한다. 모달 내부에서 useState, useRef, onChange 같은 React 훅과 이벤트 핸들러 사용하기 때문이다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span><span class="p">;</span><span class="c1">// &lt;- 모달의 인터랙션(useState, 이벤트)를 위해 필수</span>

<span class="k">import</span> <span class="nx">style</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./modal.module.css</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">useRef</span><span class="p">,</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TweetModal</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">content</span><span class="p">,</span> <span class="nx">setContent</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">imageRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">HTMLInputElement</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">onSubmit</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">};</span>
    <span class="kd">const</span> <span class="nx">onClickClose</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">onClickButton</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">}</span>
    <span class="kd">const</span> <span class="nx">onChangeContent</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">}</span>
    <span class="c1">//..</span>

    <span class="k">return</span> <span class="p">(</span>
    <span class="c1">//..</span>
                    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">inputDiv</span><span class="si">}</span><span class="p">&gt;</span>
                        <span class="p">&lt;</span><span class="nt">textarea</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">input</span><span class="si">}</span> <span class="na">placeholder</span><span class="p">=</span><span class="s">"무슨 일이 일어나고 있나요?"</span>
                          <span class="na">value</span><span class="p">=</span><span class="si">{</span><span class="nx">content</span><span class="si">}</span>
                          <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="nx">onChangeContent</span><span class="si">}</span>
                        <span class="p">/&gt;</span>
                    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
                    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">modalFooter</span><span class="si">}</span><span class="p">&gt;</span>
                            <span class="p">&lt;</span><span class="nt">button</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">actionButton</span><span class="si">}</span> <span class="na">disabled</span><span class="p">=</span><span class="si">{</span><span class="o">!</span><span class="nx">content</span><span class="si">}</span><span class="p">&gt;</span>게시하기<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
                    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="c1">//..</span>
    <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="구현하면서-이해한-것">구현하면서 이해한 것</h2>

<h3 id="modal-폴더의-의미">@modal 폴더의 @의미</h3>
<p>처음엔 왜 폴더명에 @가 붙는지 몰랐다.<br />
슬롯 문법이라고 Next.js에서 사용하는 문법이라길래, 혹시나 해서 빼봤더니, 주소로 인식해서 작동을 안 해버린다.</p>

<p>즉,</p>
<ul>
  <li>layout.tsx에서 props로 받아야 할 것을 url주소(/modal)로 받았기 때문에 지정한 컴포넌트에서 랜더링 되지 않는다.</li>
</ul>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Layout</span><span class="p">({</span> <span class="nx">children</span><span class="p">,</span> <span class="nx">modal</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;&gt;</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span>
      <span class="si">{</span><span class="nx">modal</span><span class="si">}</span>  <span class="p">&lt;</span><span class="err">-</span> <span class="err">여기에</span> <span class="err">@</span><span class="na">modal</span> <span class="err">내용이</span> <span class="err">렌더링됨</span>
    <span class="err">&lt;</span><span class="p">/&gt;</span>
  )
}
</code></pre></div></div>

<h3 id="compose-괄호의-의미">(.)compose 괄호의 의미</h3>
<p>인터셉팅 라우트 문법이다:</p>
<ul>
  <li>’(.)’ : 같은 레벨 가로채기</li>
  <li>‘(..)’ : 한 단계 위</li>
  <li>‘(…)’ : 루트부터</li>
</ul>

<p>동작 방식:</p>
<ul>
  <li>내부 버튼/링크로 /compose 이동 -&gt; (.)compose가 가로채서 모달로</li>
  <li>주소창에 /compose 직접 입력 -&gt; 전체 페이지로</li>
</ul>

<p>같은 URL인데 접근 방식에 따라 다르게 보인다.
이게 x.com이 모달과 페이지를 URL로 관리하는 방법이었다.</p>

<h3 id="defaulttsx가-3개나-되는-이유">default.tsx가 3개나 되는 이유</h3>
<p>처음엔 “왜 이렇게 많아?” 싶었다.
한 곳에만 만들면 안 되나?</p>

<p>안 된다.<br />
각 라우트 레벨마다 슬롯이 비어있을 때:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>/home 접근          -&gt; @modal/default.tsx 필요
/username/abc 접근  -&gt; @modal/[username]/default.tsx 필요
/status/123 접근    -&gt; @modal/.../[id]/default.tsx 필요
</code></pre></div></div>

<p>Next.js가 각 세그먼트마다 슬롯을 체크하기 때문에
각 레벨마다 fallback이 필요했다.</p>

<p>더미 파일 양산되는 게 단점이긴 하다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[이번은 x.com의 홈 메뉴 컨텐츠 소비 기능을 만들어 보고자 한다. 많지 않은 기능처럼 보이지만, 사용자 관점에서 필요한 기능을 쪼개본다면 몇 가지 생각해야 할 부분이 많다.]]></summary></entry><entry><title type="html">[Next.js] x-com의 나를 위한 트렌드 메뉴 만들기</title><link href="https://hwp-log.github.io/next.js/2026/02/11/next.js-session-2-21gang.html" rel="alternate" type="text/html" title="[Next.js] x-com의 나를 위한 트렌드 메뉴 만들기" /><published>2026-02-11T00:00:00+00:00</published><updated>2026-02-11T00:00:00+00:00</updated><id>https://hwp-log.github.io/next.js/2026/02/11/next.js-session%202-21gang</id><content type="html" xml:base="https://hwp-log.github.io/next.js/2026/02/11/next.js-session-2-21gang.html"><![CDATA[<p>x-com의 좌측메뉴 작성에 이어, 이번에는 우측메뉴를 작성하려고 한다.<br />
우측 메뉴는 이미지와 같이 “나를 위한 트렌드” 메뉴가 존재한다.</p>

<p><img src="/assets/post_images/2026-02-11/image0.png" alt="나를 위한 트랜드 예시" /></p>

<p>우측에 보면 Today’s News, What’s happening등 구 트위터의 “나를 위한 트렌드” 자리이다.<br />
이 부분을 오늘 구현 해 보고자 한다.</p>

<h2 id="작성방법은">작성방법은?</h2>
<p>1.작성할 로그인 이후 레이아웃 파일 확인. 
→ src/app/(afterLogin)/layout.tsx</p>

<p>2.파일 내부의 컴포넌트에서 작성할 영역 및 컴포넌트를 채워준다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ...</span>
<span class="k">import</span> <span class="nx">TrendSection</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/app/(afterLogin)/_component/TrendSection</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">FollowRecommend</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/app/(afterLogin)/_component/FollowRecommend</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">AfterLoginLayout</span><span class="p">({</span> <span class="nx">children</span> <span class="p">}:</span> <span class="p">{</span> <span class="nl">children</span><span class="p">:</span> <span class="nx">ReactNode</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
        <span class="c1">// ...</span>
            <span class="p">&lt;</span><span class="nc">TrendSection</span> <span class="p">/&gt;</span> <span class="c1">// 4-1. 나를 위한 트렌드 영역</span>
            <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">followRecommend</span><span class="si">}</span><span class="p">&gt;</span>
              <span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span>팔로우 추천<span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span> <span class="si">{</span><span class="cm">/* 4-3. 팔로우 추천 영역 */</span><span class="si">}</span>
              <span class="p">&lt;</span><span class="nc">FollowRecommend</span> <span class="p">/&gt;</span> 
              <span class="p">&lt;</span><span class="nc">FollowRecommend</span> <span class="p">/&gt;</span>
              <span class="p">&lt;</span><span class="nc">FollowRecommend</span> <span class="p">/&gt;</span>
            <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="c1">// ...</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>3.코드와 컴포넌트와의 대응</p>

<p><img src="/assets/post_images/2026-02-11/image2.png" alt="코드와 컴포넌트 대응" /></p>

<p>4.해당 컴포넌트들은 _component라는 private folder에 넣어준다.</p>

<p>4-1. TrendSection.tsx</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">style</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./trendSection.module.css</span><span class="dl">'</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Trend</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/app/(afterLogin)/_component/Trend</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TrendSection</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">trendBg</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">trend</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span>나를 위한 트렌드<span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span> <span class="si">{</span><span class="cm">/*4-2. Trend 내용*/</span><span class="si">}</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Trend</span> <span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>4-2. Trend.tsx</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="nx">Link</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/link</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">style</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./trend.module.css</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Trend</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="c1">// ?q=트렌드 -&gt; 나중에 트렌드 대신 키워드로 연결</span>
    <span class="p">&lt;</span><span class="nc">Link</span> <span class="na">href</span><span class="p">=</span><span class="si">{</span><span class="s2">`/search?q=트렌드`</span><span class="si">}</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">container</span><span class="si">}</span><span class="p">&gt;</span> 
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span><span class="p">&gt;</span>실시간트렌드<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&gt;</span>제로초<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span><span class="p">&gt;</span>1,234 posts<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Link</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>해당 /search?q=트렌드 는 URL 쿼리 파라미터로서 클릭 했을시, 설정된 관련 내용으로 서칭한다.</p>

<p>4-3. FollowRecommend.tsx</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span>
<span class="k">import</span> <span class="nx">style</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./followRecommend.module.css</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">FollowRecommend</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">onFollow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
  <span class="kd">const</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">id</span><span class="p">:</span> <span class="dl">'</span><span class="s1">elonmusk</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">nickname</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Elon Musk</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">image</span><span class="p">:</span> <span class="dl">'</span><span class="s1">/yRsRRjGO.jpg</span><span class="dl">'</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">container</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">userLogoSection</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">userLogo</span><span class="si">}</span><span class="p">&gt;</span>
          <span class="p">&lt;</span><span class="nt">img</span> <span class="na">src</span><span class="p">=</span><span class="si">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">image</span><span class="si">}</span> <span class="na">alt</span><span class="p">=</span><span class="si">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">userInfo</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">title</span><span class="si">}</span><span class="p">&gt;</span><span class="si">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">nickname</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">count</span><span class="si">}</span><span class="p">&gt;</span>@<span class="si">{</span><span class="nx">user</span><span class="p">.</span><span class="nx">id</span><span class="si">}</span><span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">followButtonSection</span><span class="si">}</span><span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">button</span> <span class="na">onClick</span><span class="p">=</span><span class="si">{</span><span class="nx">onFollow</span><span class="si">}</span><span class="p">&gt;</span>팔로우<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>5.근데 이전에 배웠던 preivate floder가 “중복파일 정리용”이라고 알고 있었는데?<br />
미리 중복될 파일을 예측하고 넣어놓는 것인가? 일단은 의문을 품은채 계속 작성해 보기로 한다.</p>

<p><img src="/assets/post_images/2026-02-11/image1.png" alt="private folder 설명" /></p>

<p>→ 용도 관련하여 다시 한번 조사 해보니, “중복파일 정리용”보다는<br />
해당라우트 그룹에서만 쓰는 컴포넌트를 모아두는 곳으로 인식하는 것이 옳다고 한다.</p>

<p><img src="/assets/post_images/2026-02-11/image4.png" alt="private folder 설명2" /></p>

<p>→ 예시의 경우는 (dashboard)에 한정하여 쓰일 컴포넌트들로 묶어서 사용하고 있다. URL로의 접근은 불가.</p>

<p>6.우측 섹션에 반영 된 것을 확인 할 수 있다.</p>

<p><img src="/assets/post_images/2026-02-11/image3.png" alt="반영내용" /></p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[x-com의 좌측메뉴 작성에 이어, 이번에는 우측메뉴를 작성하려고 한다. 우측 메뉴는 이미지와 같이 “나를 위한 트렌드” 메뉴가 존재한다.]]></summary></entry><entry><title type="html">[Next.js] Context API - TabProvider를 활용한 홈 탭 상태관리</title><link href="https://hwp-log.github.io/next.js/2026/02/11/next.js-session-2-22gang.html" rel="alternate" type="text/html" title="[Next.js] Context API - TabProvider를 활용한 홈 탭 상태관리" /><published>2026-02-11T00:00:00+00:00</published><updated>2026-02-11T00:00:00+00:00</updated><id>https://hwp-log.github.io/next.js/2026/02/11/next.js-session%202-22gang</id><content type="html" xml:base="https://hwp-log.github.io/next.js/2026/02/11/next.js-session-2-22gang.html"><![CDATA[<p>x.com의 로그인 후, 메인페이지를 보게 된다면 중앙에 ‘추천/팔로우’와 ‘내용’이 등장한다. 이때 추천/팔로우를 번갈아서 클릭 했을 때, 내용이 전환 될 필요가 존재한다.</p>

<p>문제는 ‘추천/팔로우’와’내용’의 각 컴포넌트가 형제(병렬) 관계이기 때문에, 일반적인 props 전달로는 상태를 공유 할 수 없다는 점이다.(React는 “데이터는 위에서 아래로 흐른다.” 라는 단방향 데이터흐름 설계원칙을 가지고 있어 부모 → 자식 prop전달이 기본이다.)</p>

<h2 id="형제간의-props-공유">형제간의 Props 공유?</h2>
<p>결국 이를 해결하려면, ‘공통부모에서 상태를 내려주는 방식’이 필요하고 가장 간단한 방법으로 React의 ContextAPI를 활용하는 것이다. Redux같은 외부 라이브러리 없이 React 내장 기능만으로 해결할 수 있다.
<img src="/assets/post_images/2026-02-11/image5.png" alt="Context API 사용예시" /></p>

<h2 id="그럼-적용은-어떻게">그럼 적용은 어떻게?</h2>
<h3 id="먼저-적용되는-기술은-아래와-같다">먼저 적용되는 기술은 아래와 같다.</h3>

<ul>
  <li>React Context API — createContext로 전역 상태 저장소를 만들고, Provider로 하위 컴포넌트에 공유</li>
  <li>useState — 현재 탭 상태(“rec” 또는 “fol”)를 관리</li>
  <li>“use client” — 탭 전환은 사용자 인터랙션이므로 클라이언트 컴포넌트로 선언 필요(서버 클라이언트에선 사용불가)</li>
</ul>

<h3 id="context-api---tabprovider-작성">Context API - TabProvider 작성</h3>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span><span class="p">;</span>

<span class="k">import</span> <span class="p">{</span> <span class="nx">ReactNode</span><span class="p">,</span> <span class="nx">createContext</span><span class="p">,</span> <span class="nx">useState</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 1. Context API의 createContext로 저장소를 만든다</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">TabContext</span> <span class="o">=</span> <span class="nx">createContext</span><span class="p">({</span>
  <span class="na">tab</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rec</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// 현재 탭 상태</span>
  <span class="na">setTab</span><span class="p">:</span> <span class="p">(</span><span class="na">value</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rec</span><span class="dl">"</span> <span class="o">|</span> <span class="dl">"</span><span class="s2">fol</span><span class="dl">"</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{},</span> <span class="c1">// 탭 전환 함수 ("rec" 추천 | "fol" 팔로우)</span>
<span class="p">});</span>

<span class="kd">type</span> <span class="nx">Props</span> <span class="o">=</span> <span class="p">{</span> <span class="na">children</span><span class="p">:</span> <span class="nx">ReactNode</span><span class="p">};</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TabProvider</span><span class="p">({</span> <span class="nx">children</span> <span class="p">}:</span> <span class="nx">Props</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">tab</span><span class="p">,</span> <span class="nx">setTab</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">"</span><span class="s2">rec</span><span class="dl">"</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="c1">// 2. Context API의 Provider를 활용해서 TabProvider 컴포넌트를 만듦 </span>
    <span class="p">&lt;</span><span class="nc">TabContext</span><span class="p">.</span><span class="nc">Provider</span> <span class="na">value</span><span class="p">=&gt;</span> <span class="si">{</span><span class="cm">/* value = 공유 props */</span><span class="si">}</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span> <span class="si">{</span><span class="cm">/* children = &lt;Tab /&gt;, &lt;Post /&gt; 등 형제 컴포넌트들 */</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nc">TabContext</span><span class="p">.</span><span class="nc">Provider</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>1의 경우, API 호출을 통한 TabContext를 설정해준다. Props의 기본값과 전환될 값을 설정해준다.<br />
2의 경우, 적용될 컴포넌트를 감싸준다 (value값: 스위칭 될 Props)</p>

<h3 id="homepagetsx에서의-적용">home/page.tsx에서의 적용</h3>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Home</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">main</span><span class="p">&gt;</span>
      홈페이지
    <span class="p">&lt;</span><span class="nt">main</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">main</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">TabProvider</span><span class="p">&gt;</span> <span class="si">{</span><span class="cm">/* 적용될 컴포넌트를 감싼다.*/</span><span class="si">}</span>
        <span class="p">&lt;</span><span class="nc">Tab</span><span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Post</span><span class="p">/&gt;</span> 
        <span class="p">&lt;</span><span class="nc">Post</span><span class="p">/&gt;</span>
        <span class="p">&lt;</span><span class="nc">Post</span><span class="p">/&gt;</span>
      <span class="p">&lt;/</span><span class="nc">TabProvider</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nt">main</span><span class="p">&gt;</span>
  )
}
</code></pre></div></div>
<p>Tab 컴포넌트에서 Props: rec,fol을 받으면,Post는 Props에 따라 내용을 전환해준다.</p>

<h2 id="적용-결과">적용 결과</h2>

<p><img src="/assets/post_images/2026-02-11/image6.png" alt="하드코딩 결과" /></p>

<p>아직은 상태 받는쪽의 tab.tsx에서 설정을 안해주었기에 전환은 안되는상태. 프레임만 잡았다고 생각하자.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[x.com의 로그인 후, 메인페이지를 보게 된다면 중앙에 ‘추천/팔로우’와 ‘내용’이 등장한다. 이때 추천/팔로우를 번갈아서 클릭 했을 때, 내용이 전환 될 필요가 존재한다.]]></summary></entry><entry><title type="html">[Next.js] x-com의 ActiveLink 만들기</title><link href="https://hwp-log.github.io/next.js/2026/02/09/next.js-session-2-20gang.html" rel="alternate" type="text/html" title="[Next.js] x-com의 ActiveLink 만들기" /><published>2026-02-09T00:00:00+00:00</published><updated>2026-02-09T00:00:00+00:00</updated><id>https://hwp-log.github.io/next.js/2026/02/09/next.js-session%202-20gang</id><content type="html" xml:base="https://hwp-log.github.io/next.js/2026/02/09/next.js-session-2-20gang.html"><![CDATA[<p>x-com의 좌측메뉴 작성 및 현재사용 중인 메뉴를 알기위해 사용하는 기능을 작성하려고 한다.</p>

<h2 id="activelink란">ActiveLink란?</h2>

<p><img src="/assets/post_images/2026-02-09/image0.png" alt="ActiveLink 예시" /></p>

<p>말그대로 “지금 내가 어디 페이지에 있는지 표시” 하는 기능
즉, 어느페이지에 접속해 있는지 메뉴가 볼드처리 되면서 활성화 된 기능을 뜻한다. 사용자 관점에서 본다면, 내가 어느메뉴를 사용하고 있는지 기억하고 있지는 않다. 따라서 이를 확인하려면 메뉴에 테두리가 처지던, 아니면 다른 글씨색이 되던 표시상태가 필요하다.
특히 x-com를 사용한다면, 좌:메뉴 우:내용 으로 구성되어 있기 때문에, 이런 시각적인 요소가 필요하다.</p>

<h2 id="그럼-적용은-어떻게">그럼 적용은 어떻게?</h2>

<p>작성한 서버 컴포넌트에서는 사용이 불가하기 때문에, 클라이언트 컴포넌트로 전환 해줘야 한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (afterLogin)/layout.tsx</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">ReactNode</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">style</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@/app/(afterLogin)/layout.module.css</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Link</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/link</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">Image</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">next/image</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">zLogo</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../../public/zlogo.png</span><span class="dl">"</span><span class="p">;</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">AfterLoginLayout</span><span class="p">({</span>
  <span class="nx">children</span><span class="p">,</span>
<span class="p">}:</span> <span class="p">{</span>
  <span class="nl">children</span><span class="p">:</span> <span class="nx">ReactNode</span><span class="p">;</span>
<span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">container</span><span class="si">}</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">header</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">leftSectionWrapper</span><span class="si">}</span><span class="p">&gt;</span>
        // ...
          <span class="p">&lt;</span><span class="nt">nav</span><span class="p">&gt;</span>
            <span class="p">&lt;</span><span class="nt">ul</span><span class="p">&gt;</span>
              <span class="si">{</span><span class="cm">/* NavMenu 컴포넌트
              여기를 클라이언트 컴포넌트로 바꿔줘야 한다.*/</span><span class="si">}</span>
              <span class="p">&lt;</span><span class="nc">NavMenu</span> <span class="p">/&gt;</span> 
            <span class="p">&lt;/</span><span class="nt">ul</span><span class="p">&gt;</span>
          <span class="p">&lt;/</span><span class="nt">nav</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">header</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">rightSectionWrapper</span><span class="si">}</span><span class="p">&gt;</span>
        // ...
      <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="nx">children</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<NavMenu />
<p>컴포넌트 내부에서 클라이언트 컴포넌트로 변경.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// (afterLogin)/_component/NavMenu.tsx</span>
<span class="dl">"</span><span class="s2">use client</span><span class="dl">"</span><span class="p">;</span> <span class="c1">//클라이언트 컴포넌트로 처리</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">NavMenu</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">&lt;&gt;&lt;/&gt;;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이후 useSelectedLayoutSegment()를 사용하여 현재 활성화 된 컴포넌트를 파악한다.</p>

<p>흐름은 아래와 같다.<br />
예)</p>
<ol>
  <li>사용자가 /explore 페이지에 접속</li>
  <li>NavMenu 컴포넌트가 렌더링됨</li>
  <li>useSelectedLayoutSegment()가 실행됨</li>
  <li>segment = ‘explore’ 값 리턴</li>
</ol>

<p>navbar는 그 값을 가지고 아래처럼 처리한다.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 예시</span>
<span class="p">&lt;</span><span class="nc">Link</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">segment</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">home</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">active</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">''</span><span class="si">}</span><span class="p">&gt;</span>홈<span class="p">&lt;/</span><span class="nc">Link</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">Link</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">segment</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">explore</span><span class="dl">'</span> <span class="p">?</span> <span class="dl">'</span><span class="s1">active</span><span class="dl">'</span> <span class="p">:</span> <span class="dl">''</span><span class="si">}</span><span class="p">&gt;</span>탐색하기<span class="p">&lt;/</span><span class="nc">Link</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>→ “지금 어디 페이지에 있는지” 활성화 표시</p>

<p>상세 내부는 아래와 같다.</p>
<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 예시</span>
<span class="p">&lt;</span><span class="nt">div</span> <span class="na">className</span><span class="p">=</span><span class="si">{</span><span class="nx">style</span><span class="p">.</span><span class="nx">navPill</span><span class="si">}</span><span class="p">&gt;</span>
  <span class="si">{</span><span class="nx">segment</span> <span class="o">&amp;&amp;</span> <span class="p">[</span><span class="dl">'</span><span class="s1">search</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">explore</span><span class="dl">'</span><span class="p">].</span><span class="nx">includes</span><span class="p">(</span><span class="nx">segment</span><span class="p">)</span> <span class="p">?</span> <span class="p">(</span>
    <span class="c1">// 활성 상태: /search, /explore 일 때</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nt">svg</span>
        <span class="na">width</span><span class="p">=</span><span class="si">{</span><span class="mi">26</span><span class="si">}</span>
        <span class="na">viewBox</span><span class="p">=</span><span class="s">"0 0 24 24"</span>
        <span class="na">aria-hidden</span><span class="p">=</span><span class="s">"true"</span>
        <span class="na">className</span><span class="p">=</span><span class="s">"r-18jsvk2 r-4qtqp9 r-yyyyoo r-lwhw9o r-dnmrzs r-bnwqim r-1plcrui r-lrvibr r-cnnz9e"</span>
      <span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">g</span><span class="p">&gt;</span>
          <span class="si">{</span><span class="cm">/* 활성용 아이콘 path */</span><span class="si">}</span>
          <span class="p">&lt;</span><span class="nt">path</span> <span class="na">d</span><span class="p">=</span><span class="s">"M10.25 4.25c-3.314 0-6 2.686-6 6s2.686 6 6 6c1.657 0 3.155-.67 4.243-1.757 1.087-1.088 1.757-2.586 1.757-4.243 0-3.314-2.686-6-6-6zm-9 6c0-4.971 4.029-9 9-9s9 4.029 9 9c0 1.943-.617 3.744-1.664 5.215l4.475 4.474-2.122 2.122-4.474-4.475c-1.471 1.047-3.272 1.664-5.215 1.664-4.971 0-9-4.029-9-9z"</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">g</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span> <span class="na">style</span><span class="p">=&gt;</span>탐색하기<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span> <span class="p">:</span> <span class="p">(</span>
    <span class="c1">// 비활성 상태: 그 외 나머지 경로일 때</span>
    <span class="p">&lt;&gt;</span>
      <span class="p">&lt;</span><span class="nt">svg</span>
        <span class="na">width</span><span class="p">=</span><span class="si">{</span><span class="mi">26</span><span class="si">}</span>
        <span class="na">viewBox</span><span class="p">=</span><span class="s">"0 0 24 24"</span>
        <span class="na">aria-hidden</span><span class="p">=</span><span class="s">"true"</span>
        <span class="na">className</span><span class="p">=</span><span class="s">"r-18jsvk2 r-4qtqp9 r-yyyyoo r-lwhw9o r-dnmrzs r-bnwqim r-1plcrui r-lrvibr r-cnnz9e"</span>
      <span class="p">&gt;</span>
        <span class="p">&lt;</span><span class="nt">g</span><span class="p">&gt;</span>
          <span class="si">{</span><span class="cm">/* 비활성용 아이콘 path */</span><span class="si">}</span>
          <span class="p">&lt;</span><span class="nt">path</span> <span class="na">d</span><span class="p">=</span><span class="s">"M10.25 3.75c-3.59 0-6.5 2.91-6.5 6.5s2.91 6.5 6.5 6.5c1.795 0 3.419-.726 4.596-1.904 1.178-1.177 1.904-2.801 1.904-4.596 0-3.59-2.91-6.5-6.5-6.5zm-8.5 6.5c0-4.694 3.806-8.5 8.5-8.5s8.5 3.806 8.5 8.5c0 1.986-.682 3.815-1.824 5.262l4.781 4.781-1.414 1.414-4.781-4.781c-1.447 1.142-3.276 1.824-5.262 1.824-4.694 0-8.5-3.806-8.5-8.5z"</span> <span class="p">/&gt;</span>
        <span class="p">&lt;/</span><span class="nt">g</span><span class="p">&gt;</span>
      <span class="p">&lt;/</span><span class="nt">svg</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nt">div</span><span class="p">&gt;</span>탐색하기<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;/&gt;</span>
  <span class="p">)</span><span class="si">}</span>
<span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>상태의 활성화/비활성화를 캐치해서 리턴받은뒤, 그 값에 따라 svg아이콘과 폰트의 상태를 바꿔준다.</p>

<h2 id="적용-결과">적용 결과</h2>

<p><img src="/assets/post_images/2026-02-09/image1.png" alt="ActiveLink 적용결과" /></p>

<p>해당 페이지에서 ActiveLink가 활성화 되었음을 알 수 있다.</p>]]></content><author><name></name></author><category term="Next.js" /><summary type="html"><![CDATA[x-com의 좌측메뉴 작성 및 현재사용 중인 메뉴를 알기위해 사용하는 기능을 작성하려고 한다.]]></summary></entry></feed>