---
layout: single
title: "[JavaScript] var, let, const는 왜 생겨났을까?"
date: 2026-02-20
categories: [JavaScript]
---
코딩 학습의 자연스러운 동기는 무엇일까? [이전 글](https://hwp-log.github.io/reflection/2026/02/19/reflection-1.html)에서 고민해본 결과, 그 동기는 '무언가 만들고자 하는 마음'과 '작동 원리에 대한 궁금증' 두 가지로 나뉜다는 결론에 도달했다. 이번 글에서는 후자 - 'var의 작동 원리에 대한 궁금증'부터 let, const가 왜 생겨났는지에 대한 궁금증과 학습으로 이어진 과정까지 작성 해 보려 한다.

## "var, let, const는 왜 생겨났을까?" 라는 의문
JS를 처음 배우면서 떠오르는 의문점이 뭐가 있을까? 바로 'var와 호이스팅'이라는 개념이라고 생각한다. 왜냐하면 함수랑 블록, 스코프 개념이 정립되지 않은 상태이기 때문이다. 특히 이를 코드로 쳐보지 않는 이상 누구든지 난해한 부분이다.

어쨌든 var에 대한 [공식문서](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/var) 내용을 보면, 아래와 같이 설명하고 있다.

```jsx
//var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.
var x = 1;

if (x === 1) {
  var x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 2
```

'변수를 선언, 선택적으로 초기화할 수 있습니다.' 알아듣기 어려운 추상적 개념이였다. 어떻게 이해를 해야 할까? 가정을 해보자. 코드는 기본적으로 절차지향으로 처리한다. 간단히 얘기해서 위에서 아래로 읽어 나간다는 것이다. 그렇다면 if문 블록의 var x = 2로 재선언 되었기에, 다른 주소값을 참조하는 다른 x일까? 근데 왜 if블록의 재선언 값이 전역의 x변수 값으로 출력되는 걸까?

이에 대한 의문이 더 이상 풀리지 않아서 검색을 해 보았다. 그리고 이에 관한 내용정리는 총 2가지로 나뉜다.

첫번째, 'var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.' 의 예시는 설명에 맞지 않는 예시이다.    
두번째, var는 블록안에서의 재선언 값이 전역값에 영향을 준다.

이 두 가지 내용을 하나씩 풀어보자.

## 첫번째, 'var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.' 의 예시는 설명에 맞지 않는 예시이다.

```jsx
// var 선택적 초기화 가능
var x; // (선언 + 초기화 안함) -> undefined
var y =10; // (선언 + 초기화 함) -> 10

// let 선택적 초기화 가능
let a; //가능

// const 선택적 초기화 불가
const b; // 에러! const는 반드시 초기화해야 함.
```

위의 예시는 검색을 통해 정리해 본 내용이다. 내용을 보면 결국 선택적으로 초기화 한다는 것은, 변수선언시 '초기값을 넣을지 말지를 자유롭게 지정할 수 있다는 뜻'이였다. 그렇다면 아까 봤던 첫번째 예시는 이런 특징들이 보일까?

```jsx
//var 문은 변수를 선언하고, 선택적으로 초기화할 수 있습니다.
var x = 1;

if (x === 1) {
  var x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 2
```

그렇지 않았다. 오히려 블록 스코프에서 선언한 값이 전역변수에 영향을 미친다는 것만 확인이 가능했던 예시였다. 따라서 해당 예시는 var의 특성을 보여주려다가 생긴 설명에 맞지 않는 예시라고 생각한다.

## 두번째, var는 블록안에서의 재선언 값이 전역값에 영향을 준다.

그렇다면 아까 의문이 생겼던, 예시는 어떠한가? 다른 블록에서 선언했으니 당연히 다른 변수일 거라고 생각하겠지만, 결론적으로 말하자면, var는 JS가 처음 만들어질 때, 함수 스코프를 갖고 있었기 때문에 if 블록을 벗어날 수 있게 된 것이다.

??????

JS를 처음 배웠을 때의 내 '머릿속에 지울 수 없던 혼란'이 이것 이였다. 그러나 var가 이러한 작동을 하게 된 이유는 조금 뒤에 다뤄보기로 하며, 이 말도 안 되는 선언 키워드의 작동원리에 대해 더욱 집중해 보도록 하자.

기본적으로 블록이라는 개념을 익힌 개발자라면, if문이라는 블록에서 var x = 2는 생명주기를 다했기 때문에, 전역변수에 영향을 미치지 않는다고 생각한다. 하지만, var는 함수 스코프를 구현하기 위해 호이스팅이라는 메커니즘을 넣게 되었고, 영향을 미칠 수 있게 된 것이다. 그렇다면 호이스팅의 메커니즘이 적용되는 JS 엔진의 관점에서 코드를 해석 해보자.

```jsx
// 원본
var x = 1;

if (x === 1) {
  var x = 2;

  console.log(x);
  // Expected output: 2
}

console.log(x);
// Expected output: 2
```

```jsx
// 원본 내용을 JS엔진의 관점에서 호이스팅 후 코드 해석
var x = undefined // 호이스팅된 x
x = 1; // x는 1로 재할당

if (x === 1) {
  x = 2; // 호이스팅 된 전역 변수 x는 2로 재할당

  console.log(x);
  // Expected output: 2 // 그래서 x는 최종적으로 2를 출력
}

console.log(x);
// Expected output: 2 // 이미 호이스팅 된 전역변수 x는 2이기에 2를 출력
```

즉, 다른 변수일 거라고 기대했던 if 블록 안의 x가 JS엔진의 관점에서는 처음부터 같은 x였고, 그 안에서의 할당이 그대로 바깥에 영향을 미친다는 것이다. 이것이 var의 스코프를 함수 단위로 이해해야 하는 이유다.

![호이스팅 밈](/assets/post_images/2026-02-20/image.png)
(자바스크립트 엔진이란 건, 그냥 단순하게 코드 줄을 이리저리 옮기는 정도로 돌아가는 게 아니다!)  

## var는 왜 이렇게 설계되었을까?

이 의문을 풀기 위해서는 JS가 태어난 배경을 먼저 살펴야 한다. 1995년 대략 30년전, Netscape라는 웹 브라우저라는 것이 존재했으며, Brendan Eich라는 개발자는 Netscape의 요청에 의해 인터랙티브한 기능을 넣고자 언어를 제작하게 된다. 이것이 JS의 시작이였다. 중요한 것은 이때 당시의 인터랙션(상호작용)에 대한 개념의 인식이였는데, 전화번호나 우편번호가 제대로 입력됐는지 확인하는 기능 또는 오디오를 재생하는 기능 정도의 간단한 내용이였다. 아래는 Brendan Eich의 개인 홈페이지이다. 당시의 웹의 수준을 엿볼 수 있다.

![Brendans Web World](/assets/post_images/2026-02-20/image1.png)
-> https://web.archive.org/web/19981207072942/people.netscape.com/brendan/  
당시의 홈페이지가 아직도 남아있다.

즉, 애당초 복잡한 어플리케이션을 만들 언어가 아니었다. 간단한 웹 인터랙션용 스크립트 언어에 블록 스코프까지 설계할 여유가 없었고, 함수 단위로만 변수를 관리하면 충분했다. 또한 10일이라는 시간 안에 넣을 수 있는 것도 이 정도가 한계였을 것이다.

이것이 var가 함수 스코프로 설계된 배경이다. 잘못 만든 것이 아니라, 당시 상황에서는 합리적인 선택이였다. 문제는 JS가 예상과 달리 웹의 핵심 언어로 성장하면서, 이 단순한 설계가 한계를 드러내기 시작한 것이다.

출처:[Cybercultural: 1995: The Birth of JavaScript](https://cybercultural.com/p/1995-the-birth-of-javascript/)

## let/const가 없던 시절의 처리법

var의 함수 스코프 문제를 개발자들이 몰랐던 것은 아니다. 웹이 점점 복잡해지면서 변수 충돌 문제가 실제로 발생하기 시작했고, 이를 해결하기 위한 패턴이 등장했다. 바로 IIFE(즉시 실행 함수 표현식)이다.

형태 : (function() { ... })()

예시코드는 아래와 같다.
```jsx
var count = 0;

(function() {
    if (true){
        var count = 10; // var는 함수스코프 이므로 갇힘
    }
})();

console.log(count); // count는 전역의 var를 출력. 따라서 0을 출력!
```

만약, 블록 스코프가 존재했다면 어땠을까?

```jsx
let count = 0;

if (true){
    let count = 10;
}

console.log(count); // count는 전역의 let을 출력. 따라서 0을 출력!
```

이 처럼 var의 한계를 우회하기 위한 패턴이 존재했지만, 근본적인 해결책은 아니었다. 언어 자체가 바뀌어야 했다.

## let과 const의 등장 - ES6

이후 2015년, ECMAScript6 (ES6)가 발표되면서 드디어 let과 const가 등장했다. var만으로 20년을 버텨온 JS에 드디어 블록 스코프 및 재할당 방지를 막아줄 선언방식이 새로 등장한 것이다.

### 1. 새로운 선언 방식에 블록 스코프 도입

```jsx
if (true){
    let a = 10; // let은 블록 스코프이다. 따라서 if블록 안에서 생명주기를 다함
}
console.log(a) // 참조 에러!!
```

### 2. TDZ(임시 사각지대)

```jsx
console.log(x); // undefined — 에러 없이 조용히 넘어감
var x = 10;

console.log(y); // ReferenceError — 선언 전 접근 불가
let y = 10;
```

```jsx
//JS엔진 관점
var x = undefined; // 호이스팅: 선언 + undefined로 초기화
console.log(x) // undefined — 에러 없이 조용히 넘어감
x = 10;

let y; // 호이스팅 : 선언 + 초기화 유보 (TDZ 구간)
console.log(y) // ReferenceError: y가 초기화 되기전에는 값에 접근할 수 없습니다.
y = 10; 
```

### 3. const - 재할당 방지
```jsx
const API_URL = "https://first_api.com"
API_URL = "https://second_api.com" // TypeError — const는 재할당 불가
```

변하지 말아야 할 값을 const선언을 통해 값의 변화를 막아준다.

## var, let, const 실제 응용

그렇다면 실제 응용 사례에서는 어떻게 출력될까?
아래의 예시로 연습을 해 봤다.

```jsx
var a = 1;
let b = 2;

function outer() {
    console.log("A:", a);
    b = 20;
    console.log("B:", b);
    
    if (true) {
        var a = 10;
        let b = 200;
        console.log("C:", a);
        console.log("D:", b);
    }
    
    console.log("E:", a);
    console.log("F:", b);
}

outer();
console.log("G:", a);
console.log("H:", b);
```

```jsx
// JS 엔진관점
var a = 1; 
let b = 2; // 20;

function outer() {
    var a = undefined; // 10;
    console.log("A:", a); // var a가 if문 블록에 있음으로, 호이스팅 되어 undefined를 형성한다.
    b = 20;
    console.log("B:", b); // 재할당 되어 전역 변수 2가 20이 된다.
    
    if (true) {
        let b; // 호이스팅 된 b;
        a = 10;
        b = 200;
        console.log("C:", a); // 재할당 되어, 호이스팅 된 a가 10으로 출력됨.
        console.log("D:", b); // 재선언 되어, 호이스팅 된 b가 200으로 출력됨.
    }
    
    console.log("E:", a); // outer함수 안의 a가 10으로 할당되어 있기 때문에 10으로 출력됨.
    console.log("F:", b); // 스코프 체이닝으로 전역변수 b로 올라감. b는 20으로 바뀌어 있음. 따라서 20으로 출력됨.
}

outer();
console.log("G:", a); // 전역변수 a =1임
console.log("H:", b); // 전역변수 b =20임
```

## 결론

"var, let, const는 왜 생겨났을까?"  

이 질문에 대한 답은 결국에 JS의 변천사 자체가 답이였다. Netscape가 탄생했을때, JS의 단순함은 쓰기 편안한 언어 였을 것이다. 그러나 var의 함수 스코프가 한계를 드러냈고, 개발자들은 IIFE라는 우회 패턴으로 버텨야 했다. 그리고 2015년, ES6의 let, const의 등장으로 블록 스코프, TDZ, 재할당 방지라는 근본적인 해결책이 마련되었다.

결국 이 세 선언방식의 탄생은 "완벽한 언어의 설계가 아닌, 시대에 맞게 변화해온 언어의 변화 과정"이였다. 이 과정을 직접 겪어보고 생각한 것이, 단순히 'var를 쓰지마세요'가 아닌, 다른 차원의 이해를 만들어 주었다고 생각한다.