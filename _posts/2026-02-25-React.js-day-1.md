---
layout: single
title: "[React.js] React의 학습커브는 왜 가파른 것일까?"
date: 2026-02-25
categories: [React.js]
---
React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다. 

실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 왜 만들게 된 것일까? 

이번 글에서는   
- React의 '트리구조가 탄생하게 된 배경'을 먼저 살펴보고, 
- 그 구조에 맞는 '개념과 기술'이 어떻게 만들어 졌는지 정리해 보고자 한다.  

## [탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.

15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다. 

문제는 기능과 팀원이 늘어날수록, 기능간의 영향을 주고받는 내용이 많아졌다는 것이다. 특히, 하나의 기능을 수정하면 예상치 못한 다른 부분이 깨지고, 깨진부분을 이해하고 수정하는 데 많은 비용이 들었다. 비용의 증가는 신기능 출시 및 개선 속도에도 영향을 미치기 시작했다.

![페이스북, 2004년(좌)& 2011년(우)](/assets/post_images/2026-02-25/facebook.png)  
좌 : 2004년 페이스북 | 우 : 2011년 페이스북  
출처 : [CNET](https://www.cnet.com/pictures/facebook-then-and-now-pictures/)  

이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식 방식이 필요하게 된 것이다.

이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크 React.js가 탄생하게 된다.

## [탄생배경 2] 그렇다면 니즈가 쌓이게 된 원인은 무엇이었을까?

facebook은 MVC 스타일 구조와 양방향/단방향 데이터 흐름 패턴을 많이 사용하고 있었다. 이 방식은 초기화면처럼 단순할 때, 잘 동작했었다.

![mvc패턴](/assets/post_images/2026-02-25/mvc00.png)  
출처 : 본인

그러나 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다. 그 한계는 앞서 말했던 '기능간의 영향을 주고 받는 내용이 많아진 점', 그리고 이러한 내용이 대량으로 발생하면서 연쇄적인 업데이트(cascading updates) 폭증하게 된 것이다.

![mvc패턴](/assets/post_images/2026-02-25/mvc22.png)  
출처 : 본인

핵심은 이런 '예측불가 패턴'이 '여러 기능에서 동시에 발생'하여, '어디서 전파되고 어디로 재전파 되는지'를 알 수 없게 되는 현상이 연쇄적인 업데이트(cascading updates)인 것이다.

물론, 기능이 적은 상태에서는 많은 데이터를 관리하지 않았기 때문에 추적이 가능했을 것이다. 하지만 점차 이러한 패턴이 폭증하게 되었고 이는 유지보수의 니즈로서 구체화 되기 시작했다.

![페이스북의 복잡해진 MVC패턴](/assets/post_images/2026-02-25/mvc.png)  
출처 : [InfoQ](https://www.infoq.com/news/2014/05/facebook-mvc-flux/) 

## [사례와 해결책] 안 읽은 메시지 기능과 Flux 패턴

그렇다면 그 사례는 어떤 것이 있을까? 페이스북에서는 "실제로 새 메시지가 없는데도 새 메시지가 있다고 사용자에게 알리는 채팅버그"가 있었다. 이는 앞서 말한 "연쇄적인 업데이트 내용이 폭증"하면서, 모델에 수시로 값이 갱신되고 어느 부분에서 값이 바뀌었는지 알 수 없었기에 생긴 버그였다.

그리고 이를 해결하고자 했던 패턴이 Flux패턴이였다.

![flux 패턴](/assets/post_images/2026-02-25/flux.png)  
출처 : [InfoQ](https://facebookarchive.github.io/flux/docs/in-depth-overview/) 

처음 본다면, 헷갈릴 수 있는데 핵심만 말하자면 아래와 같다.

1. 핵심은 Store에 저장되는 '기능별 상태정보' 이다.  
2. 연쇄적인 업데이트가 많아지면... 어느 Model에서 값이 변경 되었는지 알 수 없었다.  
3. 이를 해결해 주는게 dispatcher과 Store(정해진 도메인들이 모인 Model영역)이다.  
4. dispatcher는 액션을 모든 Store에 전달하는 단일통로이다. 
5. dispatcher는 한 액션이 처리되는 동안 상태변경이 단 한번의 path로만 일어나도록 강제한다.  
6. "안 읽은 메시지","채팅 목록"등의 관련 기능은 모두 Store에서 값을 읽기 때문에, 값이 헷갈리지 않게 된다.
7. 예시 이미지에서는 Store 하나로 고정되어 있지만, 이전 MVC패턴에서는 관련 없는 모델로 값이 튀는 것이 문제였다.

이렇게 보면, Flux는 "View/Model이 어디서 끝나는지 모르는 스파게티 흐름"을 
한 방향으로 고정하고, 최종책임을 Store에서 확인 할 수 있는 구조가 되는 것이다.

간단히 말하자면...  

- 양방향 : 

[Model기능1 <-> ViewA <-> Model기능?? <-> View??]

- 한방향 :

[ViewA -> Action -> Dispatcher -> Store(기능A)]
[ViewA -> Action -> Dispatcher -> Store(기능B)]

즉, 핵심은 Dispatcher를 통한 '고정된 경로를 거쳐 지정된 Store만 갱신해 준다는 것이다.'
이렇듯 '여러 모델'로 값이 튀지 않게 '정해진 도메인 기능들의 모델영역(해당 기능의 Store)'로만 가기 때문에 단방향이라고 말하는 것이다.

이는 '고정된 경로'랑 '저장장소'를 제공하여, 어디서 어떤 상태가 바뀌는지 추적을 쉽게 할 수 있게 해준다. 또한 하나의 액션이 발생하면, 관련된 여러 Store가 그 액션을 각자 해석해 상태를 갱신할 수 있겠지만, 이 모든 과정은 항상 Action -> Dispatcher -> Store -> View 라는 고정된 흐름 안에서 일어나기 때문에, 기존의 "예상치 못한 곳에서 값이 튀는" 현상을 크게 줄일 수 있는 것이다.