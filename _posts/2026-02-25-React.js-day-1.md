---
layout: single
title: "[React.js] React의 학습커브는 왜 가파른 것일까?"
date: 2026-02-25
categories: [React.js]
---
React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다. 

실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 왜 만들게 된 것일까? 

이번 글에서는   
- React의 '트리구조가 탄생하게 된 배경'을 먼저 살펴보고, 
- 그 구조에 맞는 '개념과 기술'이 어떻게 만들어 졌는지 정리해 보고자 한다.  

## [탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.

15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다. 

문제는 기능과 팀원이 늘어날수록, 기능간의 영향을 주고받는 내용이 많아졌다는 것이다. 특히, 하나의 기능을 수정하면 예상치 못한 다른 부분이 깨지고, 깨진부분을 이해하고 수정하는 데 많은 비용이 들었다. 비용의 증가는 신기능 출시 및 개선 속도에도 영향을 미치기 시작했다.

![페이스북, 2004년(좌)& 2011년(우)](/assets/post_images/2026-02-25/facebook.png)  
좌 : 2004년 페이스북 | 우 : 2011년 페이스북  
출처 : [CNET](https://www.cnet.com/pictures/facebook-then-and-now-pictures/)  

이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식 방식이 필요하게 된 것이다.

이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크 React.js가 탄생하게 된다.

## [탄생배경 2] 그렇다면 니즈가 쌓이게 된 원인은 무엇이었을까?

facebook은 MVC 스타일 구조와 양방향/다방향 데이터 흐름 패턴을 많이 사용하고 있었다. 이 방식은 초기화면처럼 단순할 때, 잘 동작했었지만, 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다.

그 한계는 앞서 말했던 '기능간의 영향을 주고 받는 내용이 많아진점', 그리고 이러한 내용이 대량으로 발생하면서 연쇄적인 업데이트(cascading updates) 폭증하게 된 것이다.

그렇다면 이러한 연쇄적인 업데이트는 무엇을 말하는건가? MVC패턴을 생각해보자, 사용자가 입력을 하면 View에서 Controller를 거쳐 Model이 갱신되고, 다시 갱신된 Model은 View에 재랜더링 하게되는 방식이다.  

즉, [ 입력(Input) -> 모델(Model) -> 출력(Output) ]의 패턴 인것이다. 
이 사이클은 여기서만 끝난다면, "어느 지점에서 어떤 값이 바뀌는지" 쉽게 예측할 수 있다.

문제는... 여기서 끝이 아니였던 것이다. 만약 세번째 단계인, '출력단계(Output)에서 끝나지 않고, 자동으로 입력(Input) 트리거'가 다시 작동한다면 어떻게 될까?

고정적으로 생각하는 것 : [ 입력(Input) -> 모델(Model) -> 출력(Output) ]
자동입력 트리거가 있을 경우 : [ 입력(Input) -> 모델(Model) -> 출력(Output) & 자동 트리거 입력(Input) -> 모델(Model -> ...)]   

출력 이후, 자동 트리거 입력(Input)이 작동하여 Model, View를 다시 왕복 하게 될것이다. 이것이 '어디서 무엇이 전파되고 다시 재전파 되는지'를 말하는 연쇄적인 업데이트(cascading updates)이다.

물론, 기능이 적은 상태에서는 많은 데이터를 관리하지 않았기 때문에 추적이 가능했을 것이다. 하지만 아래 사진처럼 기능이 추가되면서, 이러한 패턴이 폭증하게 되었고 이는 유지보수의 니즈로서 구체화 되기 시작했다.

![페이스북의 복잡해진 MVC패턴](/assets/post_images/2026-02-25/mvc.png)  
출처 : [InfoQ](https://www.infoq.com/news/2014/05/facebook-mvc-flux/) 

## [사례] 안 읽은 메시지 기능에서 생긴 일

그렇다면 그 사례는 어떤 것이 있을까? 앞서 말한 것처럼 문제의 핵심은 'view의 자동 트리거를 통한 재전파를 통한 예측불가성' 이였다. 모델에 수시로 갱신되면서 어느 부분에서 값이 바뀌었는지 쪼개서 보더라도 누가 최종책임을 지는지 알기 힘든 상황이였다.

이를 해결하고자 했던 패턴이 Flux패턴이였다.

![flux 패턴](/assets/post_images/2026-02-25/flux.png)  
출처 : [InfoQ](https://facebookarchive.github.io/flux/docs/in-depth-overview/) 

처음 본다면, 헷갈릴 수 있는데 핵심만 말하자면 아래와 같다.

1. 핵심은 Store에 저장되는 '기능별 상태정보' 이다.  
2. 연쇄적인 업데이트가 많아지면... View에서 끝나는지, Model에서 끝나는지 알 수 없었다.  
3. 이를 해결해 주는게 dispatcher과 Store이다.  
4. dispatcher는 액션을 모든 Store에 전달하는 단일통로이다. 
5. dispatcher는 한 액션이 처리되는 동안 상태변경이 단 한번의 path로만 일어나도록 강제한다.  
6. "안 읽은 메시지","채팅 목록"등의 기능은 모두 Store에서 값을 읽기 때문에, 값이 헷갈리지 않게 된다.

이렇게 보면, Flux는 "View/Model이 어디서 끝나는지 모르는 스파게티 흐름"을 
한 방향으로 고정하고, 최종책임을 Store에서 확인 할 수 있는 구조가 되는 것이다.

기존(양방향) : [ Input(view) -> Model#1 -> Output(view) -> Model#??('어느 모델로 튈지 모름') -> ...]
개선(단방향) : [ Input(View) -> Action(controller) -> Dispatcher(controller) -> Store('정해진 도메인 기능들의 모델') -> Output(View) -> ...]

그렇다면 여기서 양방향과 단방향의 차이는 무엇일까? 

- 양방향 : 
View가 Model을 직접바꾸고 Model이 또 다른 View를 바꾸고, 그 View가 다시 또다른 Model을 바꾸는 식으로 여러 방향, 경로가 업데이트가 되는 구조

- 단방향 :
View 입력이 Dispatcher, Store를 거쳐 View랜더 한방향 루프만 돌고 끝나는 구조

즉, 핵심은 Dispatcher를 통한 고정된 경로를 거쳐 지정된 Store만 갱신해 준다는 것이다. 이렇듯 '여러 모델'로 값이 튀지 않게 '정해진 도메인 기능들의 모델(해당 기능의 Store)'로만 가기 때문에 단방향이라고 말하는 것이다.

이는 '고정된 경로'랑 '저장장소'를 제공하여, 디버깅을 용이하게 하기 위한 아이디어인 것이다.