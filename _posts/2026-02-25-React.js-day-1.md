---
layout: single
title: "[React.js] React의 학습커브는 왜 가파른 것일까?"
date: 2026-02-25
categories: [React.js]
---
React의 학습커브는 왜 가파른 것일까? 컴포넌트에 대한 이해? 단방향 데이터 흐름? hook개념? 무엇이 어렵다고 특정짓기 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 JS로 분리해서 인터렉션을 구성하던 개발자 입장에서는 이러한 개념이 한눈에 들어오지 않기 때문이다. 

실제로 본인도 JS로 각 Dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응하는 컴포넌트 단위로의 사고전환에 어려운 점이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고, 이에 맞는 프레임워크를 왜 만들게 된 것일까? 

이번 글에서는   
- React의 '구조가 탄생하게 된 배경'을 먼저 살펴보고, 
- 그 구조에 맞는 '개념과 기술'이 어떻게 만들어 졌는지 정리해 보고자 한다.  

## [탄생배경 1] 2011년, facebook은 점점 복잡해지고 있었다.

15년전인 2011년, 페이스북은 초기의 모습과 달리 웹 앱의 구조가 복잡해지기 시작했다. 광고와 뉴스피드 같은 기능이 계속 추가되면서 코드는 비대해졌고, 이를 유지/개선하기 위해 더 많은 인력이 투입되었다. 

문제는 기능과 팀원이 늘어날수록, 기능간의 영향을 주고받는 내용이 많아졌다는 것이다. 특히, 하나의 기능을 수정하면 예상치 못한 다른 부분이 깨지고, 깨진부분을 이해하고 수정하는 데 많은 비용이 들었다. 비용의 증가는 신기능 출시 및 개선 속도에도 영향을 미치기 시작했다.

![페이스북, 2004년(좌)& 2011년(우)](/assets/post_images/2026-02-25/facebook.png)  
좌 : 2004년 페이스북 | 우 : 2011년 페이스북  
출처 : [CNET](https://www.cnet.com/pictures/facebook-then-and-now-pictures/)  

이 상태에서 페이스북의 엔지니어들은 코드 유지/보수자체가 점점 더 어려워지고 있다는 사실에 직면하게 되었다. 복잡해진 UI를 더욱 효율적인 방식으로 이해하고, 다룰 수 있는 방식이 필요하게 된 것이다.

이러한 내부적인 니즈가 쌓인 끝에, 복잡한 UI를 다루기 위한 프레임워크 React.js가 탄생하게 된다.

## [탄생배경 2] 그렇다면 니즈가 생기게 된 원인은 무엇이었을까?

facebook은 MVC 스타일 구조와 양방향/단방향 데이터 흐름 패턴을 많이 사용하고 있었다. 이 방식은 초기화면처럼 단순할 때, 잘 동작했었다.

![mvc패턴](/assets/post_images/2026-02-25/mvc12.png)  
출처 : 본인

그러나 기능과 화면이 복잡해질수록 점점 한계를 드러내기 시작했다. 그 한계는 앞서 말했던 '기능간의 영향을 주고 받는 내용이 많아진 점', 그리고 이러한 내용이 대량으로 발생하면서 연쇄적인 업데이트(cascading updates)가 폭증하게 된 것이다.

![mvc패턴](/assets/post_images/2026-02-25/mvc3.png)  
출처 : 본인

핵심은 이런 '예측불가 패턴'이 '여러 기능에서 동시에 발생'하여, '어디서 전파되고 어디로 재전파 되는지'를 알 수 없게 되는 현상이 연쇄적인 업데이트(cascading updates)인 것이다.

물론, 기능이 적은 상태에서는 많은 데이터를 관리하지 않았기 때문에 추적이 가능했을 것이다. 하지만 점차 이러한 패턴이 폭증하게 되었고 이는 개발 및 유지보수의 니즈로서 구체화 되기 시작했다.

![페이스북의 복잡해진 MVC패턴](/assets/post_images/2026-02-25/mvc.png)
-> 기능(Action) 하나를 기준으로 했을때의 cascading update의 모습 | 이때도 찾기가 어렵다.
-> 기능(Action) 하나가 아닌 여러개가 동시에 움직이면? 갱신되는 Modle 값이 추적이 불가하다.
출처 : [InfoQ](https://www.infoq.com/news/2014/05/facebook-mvc-flux/) 

## [사례와 해결책] '안 읽은 메시지 기능'과 'Flux 패턴'

그렇다면 그 사례는 어떤 것이 있을까? 페이스북에서는 "실제로 새 메시지가 없는데도, 새 메시지가 있다고 사용자에게 알리는 채팅버그"가 있었다. 이는 앞서 말한 "연쇄적인 업데이트 내용이 폭증"하면서, 모델에 수시로 값이 갱신되고, 어느 부분에서 값이 바뀌었는지 알 수 없었기에 생긴 버그였다.

그리고 이를 해결하고자 했던 패턴이 Flux 패턴이였다.

![flux 패턴](/assets/post_images/2026-02-25/flux.png)  
출처 : [InfoQ](https://facebookarchive.github.io/flux/docs/in-depth-overview/) 

처음 본다면, 헷갈릴 수 있는데 핵심만 말하자면 아래와 같다.

1. 핵심은 Store에 저장되는 '기능별 상태정보' 이다.  
2. 연쇄적인 업데이트가 많아지면... 어느 Model에서 값이 변경 되었는지 알 수 없었다.  
3. 이를 해결해 주는게 dispatcher과 Store(정해진 도메인들이 모인 Model영역)이다.  
4. dispatcher는 액션을 모든 Store에 전달하는 단일통로이다. 
5. dispatcher는 한 액션이 처리되는 동안 상태변경이 단 한번의 path로만 일어나도록 강제한다.  
6. "안 읽은 메시지","채팅 목록"등의 관련 기능은 모두 Store에서 값을 읽기 때문에, 값이 헷갈리지 않게 된다.
7. 예시 이미지에서는 Store 하나로 고정되어 있지만, 이전 MVC패턴에서는 관련 없는 모델로 값이 튀는 것이 문제였다.

이렇게 보면, Flux는 "View/Model이 어디서 끝나는지 모르는 스파게티 흐름"을 
단방향으로 고정하고, 최종책임을 Store에서 확인 할 수 있는 구조가 되는 것이다.

![mvc패턴](/assets/post_images/2026-02-25/mvc4.png)  

이는 '고정된 경로'랑 '저장장소'를 제공하여, 어디서 어떤 상태가 바뀌는지 추적을 쉽게 할 수 있게 해준다. 또한 하나의 액션이 발생하면, 관련된 Store들이 각자 상태를 갱신할 수 있겠지만, 이 모든 과정은 항상 Action -> Dispatcher -> Store -> View 라는 단방향 흐름 안에서 일어나기 때문에, 기존의 "예상치 못한 곳에서 값이 튀는" 현상을 크게 줄일 수 있는 것이다.

## [엔진과 개념] React는 어떻게 진화해왔을까?
앞부분에서 페이스북이 복잡해지면서 Flux 패턴이 등장한 이야기를 했었다. 이제부터는 그 흐름이 실제 React 코드와 엔진에서 어떻게 드러나는지, 최대한 설명해보고자 한다. 설명해보가자 하는 내용은 아래와 같다.

1. 처음에는 Class 컴포넌트로 시작했고
2. 이후에 함수컴포넌트 + Hooks로 패러다임이 바뀌었고
3. 내부 엔진은 Fiber라는 구조로 완전히 갈아엎어졌고
4. 최근에는 동시성 랜더링 개념까지 얹혀지게 되었다.

이러한 모든걸 한번에 접하다보니, 배우는 입장에서는 당연히 부담스럽게 느껴질 수 밖에 없다. 그럼 이러한 개념을 동시에 보지말고, 하나씩 파보자.

### 1. Class컴포넌트 - "모든 걸 한 클래스 안에 넣던 시절"

React 초창기에는 컴포넌트를 클래스로 만들었다. 왜냐하면 초기의 React는 "상태와 로직을 품은 UI조각"을 표현하려고 했었고, 그 시점에서 가장 현실적인 도구가 클래스였기 때문이다. 당시 JS를 통해 인터렉션을 개발하는 개발자들은 물론이고 React팀에서도 개발단위의 기본을 Class라고 생각했었다. 그러나 이러한 내용은 예상과 다르게 Class단위 기능이 아닌 function단위 기능으로만 쓰게 되는데... 이 부분은 function 패러다임으로 바뀌는 다음 내용에서 언급하도록 하겠다.

어쨌든 본론으로 돌아와서 '클래스 컴포넌트'의 내용은 아래와 같다.
```jsx
  import React from 'react';

  class Hello extends React.Component{
    render(){
      return <div>안녕하세요, {this.props.name}님!</div>;
    }
  }

// <Hello name="user">
// return값 : <div> 안녕하세요, user님! </div>
```
- Hello 라는 클래스를 만들고
- React.Component를 상속받고
- render() 메서드에서 JSX를 반환하여, 출력값을 리턴해준다.

그렇다면, 상태(state)를 가지는 클래스 컴포넌트 형태는 어땠을까?

```jsx
import React from 'react';

class Counter extends React.Component {
  construcor(props){
    super(props);
    // 컴포넌트의 초기 상태
    this.state = {count:0};
  }

  handleClick=()=>{
    // 상태를 바꿀때 setState를 사용
    this.setState(count:this.state.count + 1);
  }

  render(){
    return(
      <button onClick={this.handleClick}>
        클릭 수:{this.state.count}
      </button>
    )
  }

}
```

여기서의 포인트는 this.state 에 상태를 넣고, this.setState() 로만 상태를 바꾼다는 점이다.
이게 기본적으로는 한눈에 들어와서 문제가 안될 것 같지만... 라이프 사이클까지 섞은 실서비스가 되면 아래처럼 더욱 복잡해진다.

```jsx
  class Counter extends React.Component{
    constructor(props){
      super(props);
      // 이벤트 핸들러로 상태 갱신
      this.state = {count:0};
    }

    componentDidMount(){
      // 라이프사이클 1
      console.log('컴포넌트가 화면에 등장')
    }

    componentDidUpdate(prevProps, prevState){
      // 라이프 사이클 2
      if(prevState.count !== this.state.count)}{
        console.log('count가 바뀜:',this.state.count)
      }
    }

    componentWillUnmount(){
      // 라이프 사이클 3
      console.log('컴포넌트가 화면에서 사라짐');
    }

    handleClick = () => {
      // 이벤트 핸들러
      this.setState({count:this.state.count + 1});
    }

    render(){
      return(
        <button onClick={this.handleClick}>
          클릭 수:{this.state.count}
        </button>
      )
    }
  }
```

즉, 상태관련 코드가 constructor, 라이프사이클 메서드들(1,2,3), 이벤트핸들러로 산개된다.  
기능이 많아질수록 하나의 클래스 파일이 점점 비대해진다는 것이다. 그래서 유지보수를 하면서 이러한 피로감이 증대하게 되는 것이 문제점이였다. 이를 React팀에서 다시 생각하기 사작한 것이다.

### 2. 함수 컴포넌트와 Hooks - '어쨌든 UI는 그냥 함수잖아?'
React 팀이 다시 생각한 포인트는 이것이다.

"UI는 결국 state -> UI로 매핑되어 바뀌는 함수 아닌가?"  
생각해보자. 굳이 클래스 형태가 아니더라도 바뀌는 단위는 클래스가 아니라 함수 아니였나?
그럼 함수단위로 최소한 쪼개보자. 어떠한가?
```jsx
function hello({name}){
  return <div> 안녕하세요, {name}님!</div>;
}

// <hello name="user">
// retrun값 : 안녕하세요, user님!
```

이렇게 보면 직관적이고 한눈에 들어오게 된다.

### 3. Hook이 없던 시절의 한계
그러나 초창기에는 함수 컴포넌트가 상태나 라이프사이클을 가질 수 없었다. Class단위로 설계가 되었기 때문이다. 그래서 상태나 생명주기가 필요해지는 순간(기능이 복잡해 지는 순간)에는 그 부분은 클래스 컴포넌트로 구현해야 했다.

당시의 함수 컴포넌트 아래의 용도로 쓰였었다.
- 함수 컴포넌트 : 단순표시용
- 상태/라이프사이클 필요시 : 클래스 컴포넌트

이러한 이중 구조가 점점 거슬리기 시작했고, "함수에서도 상태를 쓰고 싶다"는 니즈가 점점 커지게 되었다.

### 4. Hook의 등장 - 함수에 "상태와 생명주기"를 심어주기
그래서 나온 것이 Hook이다.
Hook은 "함수 컴포넌트 안에서 React 기능을 쓸 수 있게 해주는 함수"라고 생각하면 된다.
```jsx
import {useState, useEffect}from 'react';

function Counter(){
  //count라는 상태값과 그걸 바꾸는 setCount함수를 만든다.
  // 상태
  const [count, setCount] = useState(0);

  //count가 바뀔 때마다 콘솔에 로그를 남긴다.
  // 라이프 사이클(1,2,3)
  useEffect(() => {
    console.log('현재 count:',count);
  }, [count]);

  return (
    <button onClick={()=>setCount(count + 1)}>
      클릭수:{count}
    </button>
  )
}
```
여기서 포인트는
- useState(0) : 초기값 0으로 상태 슬롯 하나 생성
- useEffect(... , [count]) : useEffect가 실행되면,그리고 의존성 count콜백이 바뀔 때마다 실행되는 "후처리 작동" 등록

결론적으로 클래스에서 여기저기 산개된 것들이, 하나의 함수 안으로 모여 들어온 느낌이다.

하지만 대가도 있다.
- Hook은 항상 컴포넌트 최상단에서, 매 랜더링마다 같은 순서로 호출되어야 한다.(if,while등과 같은 조건문 안에 작성금지!)
- 랜더링이 다시 일어날 때마다 이 함수가 통째로 다시 실행된다는 점을 이해해야 한다.
- useEffect의 실행시점, 의존성 배열등을 이해하지 않으면 이상한 버그를 만나기 쉽다.(최소조건의 구조로 작성해야함)

그래서 문법 자체는 직관적으로 변했는데, "작동 원리까지 같이 이해해야 하는" 새로운 난이도가 생긴 것이다.
상기의 세개의 부분은 중요하지만...다음 글에서 차후 다뤄보기로 하겠다. 현재는 "학습커브가 왜 가파른지"에 대해 언급하는 내용이기에 문맥을 해칠수 있어서 건너뛰는 것이다. 분명한것은 Vanila JS인 경우 수학적으로 딱딱 떨어지는 분자단위의 논리와 같다면, react와 같은 프레임워크는 프로토콜같은 추상단위의 개념으로 봐야 이해하기 용이하다는 것이다. 간단히 얘기하자면, 논리의 앞뒤가 맞기 이전에 의도가 무엇인지 부터 파악해야 한다는 것이다. 그 뒤에 안의 논리를 분자단위로 쪼개도 이해는 늦지 않다.

### 5. React 구엔진 - "처음부터 끝까지 그리자"
지금까지는 "React의 추상개념과 그 단위를 어떻게 코드로 쓰느냐"에 대한 이야기였다.
이제는 "그 코드를 React가 내부에서 어떻게 처리하는지" 엔진에 대해서 살펴보자.

옛날 React는 랜더링을 시작하면, 한번에 끝까지 처리하는 방식이였다.
1. 컴포넌트의 트리구조(상하 구조)가 거대하거나
2. 랜더링 해야 할 일이 많으면 

그 작업이 끝날 때까지 브라우저에 제어권을 돌려주지 못해서,
3. 잠깐 스크롤이 끊기거나
4. 입력 반응이 느려지는

"버벅임"이 생길 수 있었다.

이 문제를 해결하려고 도입한 것이 React Fiber였다.
간단히, 얘기하자면 하나의 큰 작업단위를 각각의 단위별로 쪼개서 작업의 우선순위를 두자는 취지였던 것이다.
1. 각각의 컴포넌트를 "fiber"라는 작업 단위 객체로 관리하고
2. 이 작업들을 쪼개서 여러 프레임에 나눠서 처리한다.
3. 중요한 것은 하나의 긴작업이 동기화 되면 멈추지 못하는 것이 아닌, 
4. 쪼개진 단위에서 처리하다가 필요하면 멈추고 다른 우선순위를 먼저 실행시킨다는 것이다.

덕분에 현재 React에서는
- 지금 당장 급한 작업(예:Input)이 생기면 그걸 먼저 처리하고
- 급하지 않은 랜더링 컴포넌트는 나중으로 미룰 수 있다는 것이다.

개발자가 Fiber객체를 직접 다루지는 않지만, 이 구조 덕분에 UI가 "덜 버벅이는" 방향으로 개선 될 수 있었다.