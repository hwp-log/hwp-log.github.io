---
layout: single
title: "[React.js] React의 학습커브는 왜 가파른 것일까?"
date: 2026-02-25
categories: [React.js]
---
React를 처음 배우는 개발자들의 공통적인 의견은 무엇이 있을까? 컴포넌트에 대한 이해?, 단방향 데이터 흐름?, hook? 무엇이 어렵다고 특정짓기는 어렵지만, 개인적인 생각으로는 이러한 개념을 한 번에 이해해야하는 부담이 아닐까 싶다. 왜냐하면 js로 분리해서 인터렉션을 구성하던 개발자 입장에서는 한눈에 들어오지 않기 때문이다. 

실제로 본인도 JS로 각 dom의 인터렉션을 지정해서 작성하다가, React의 트리구조와 대응되는 컴포넌트 단위 사고로의 전환에 어려운 부분이 많았다. 그렇다면 이러한 전환이 필요했던 이유는 무엇이였을까? 굳이 쪼개서 생각하지 않아도 될 부분을 왜 쪼개고 이에 맞는 프레임워크를 만들게 된 것일까? 이번 글에서는 이러한 '구조가 탄생된 배경을 이해'하고 '구조에 맞는 기술'이 왜 만들어 졌는지에 대해 다뤄보고자 한다.

## 2011년, FaceBook은 더 복잡해지고 있었다.

15년전인 2011년, 페이스북은 초기의 모습과 달리 점점 구조가 복잡해 지기 시작했다. 페이스북 광고 및 뉴스피드와 같은 기능이 들어가며, 더욱 많은 인력이 요구되었고 팀원 수와 앱 기능 관리는 업무 속도의 효율을 떨어트리게 되었다. 이는 앱의 업데이트 속도를 늦추게 되는 결과를 낳게 되었다. 

![페이스북, 2004년(좌)& 2011년(우)](/assets/post_images/2026-02-25/facebook.png)  
좌 : 2004년 페이스북 | 우 : 2011년 페이스북  
출처 : [CNET](https://www.cnet.com/pictures/facebook-then-and-now-pictures/)  

이 상태에서 페이스북의 엔지니어들은 코드의 유지보수 조차 어렵게 되었는데, 이는 필연적으로 업무 프로세스를 효율적으로 만드는 도구가 필요했던 것이다. 이것이 React.js가 생기게 된 계기이다.

## 업데이트 속도를 늦추게 한 본질적인 원인은 무엇이였을까?

원래 FaceBook은 MVC패턴의 양방향 모델 구조였다. 이는 초기의 단순구조였던, FaceBook에서는 채용이 가능했던 구조였지만, 점점 복잡해 지면서 양방향 구조의 한계를 느끼게 된다. 그렇다면 그 구조의 한계는 무엇이였을까? 바로 예측불가 코드였던 것이다.


![React.js Conf 2015 Keynotes](/assets/post_images/2026-02-25/unpredcitable_code.png)
출처 : [React.js Conf 2015 Keynote](https://www.youtube.com/watch?v=KVZ-P-ZI6W4&list=PLb0IAmt7-GS1cbw4qonlQztYV1TAW0sCr&index=2)

아래의 단방향과 양방향에 내용을 넣어보자. 어떻게 작동하는가?

<div id="data-flow-demo">
  <h1>대규모 앱 데이터 흐름 시각화</h1>
  <p>입력창에 글자를 타이핑하며 데이터가 어떻게 전파되는지 관찰하세요.</p>


  <div class="container">
    <!-- 단방향 -->
    <div class="box" id="one-way-container">
      <h2>단방향 (One-way)</h2>
      <div class="state-box">중앙 Store (State): <span id="one-way-state">""</span></div>
      <input type="text" id="one-way-input" placeholder="여기에 입력 (View)">
      <div class="component-tree">
        <div style="font-weight:bold; margin-bottom:5px;">Component Tree (하향식 전파)</div>
        <div class="node" id="ow-node-1">Header 컴포넌트: <span class="val">""</span></div>
        <div class="node" id="ow-node-2">Content 컴포넌트: <span class="val">""</span></div>
        <div class="node" id="ow-node-3">Footer 컴포넌트: <span class="val">""</span></div>
      </div>
      <div class="log" id="one-way-log">이벤트 로그가 여기에 표시됩니다.</div>
      <p style="font-size: 12px; color: #888;">* 입력 -> Action 발생 -> State 변경 -> UI 전체 전파</p>
    </div>


    <!-- 양방향 -->
    <div class="box" id="two-way-container">
      <h2>양방향 (Two-way)</h2>
      <div class="state-box">Model (Data Object): <span id="two-way-state">""</span></div>
      <input type="text" id="two-way-input" placeholder="여기에 입력 (View/Model)">
      <div class="component-tree">
        <div style="font-weight:bold; margin-bottom:5px;">Connected Views (자동 동기화)</div>
        <div class="node" id="tw-node-1">프로필 이름: <span class="val">""</span></div>
        <div class="node" id="tw-node-2">알림 설정: <span class="val">""</span></div>
        <div class="node" id="tw-node-3">실시간 미리보기: <span class="val">""</span></div>
      </div>
      <div class="log" id="two-way-log">이벤트 로그가 여기에 표시됩니다.</div>
      <p style="font-size: 12px; color: #888;">* 입력 = State 변경 (즉시 연결)</p>
    </div>
  </div>
</div>

<style>
  /* data-flow-demo 영역에만 스타일 적용되도록 앞에 #data-flow-demo 붙임 */
  #data-flow-demo { font-family: sans-serif; }
  #data-flow-demo .container { display: flex; gap: 40px; width: 100%; max-width: 1000px; }
  #data-flow-demo .box { flex: 1; background: white; padding: 20px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); position: relative; }
  #data-flow-demo h2 { text-align: center; color: #333; margin-bottom: 30px; }
  #data-flow-demo .component-tree { border: 2px dashed #ccc; padding: 15px; margin-top: 20px; border-radius: 8px; }
  #data-flow-demo .node { padding: 10px; border: 1px solid #ddd; margin: 5px 0; border-radius: 4px; background: #fafafa; font-size: 13px; transition: all 0.3s; }
  #data-flow-demo .active { background: #e3f2fd; border-color: #2196f3; transform: scale(1.02); }
  #data-flow-demo .state-box { background: #333; color: #fff; padding: 10px; border-radius: 6px; margin-bottom: 20px; text-align: center; }
  #data-flow-demo input { width: 100%; padding: 10px; box-sizing: border-box; margin-bottom: 10px; border: 2px solid #ddd; border-radius: 4px; outline: none; }
  #data-flow-demo input:focus { border-color: #2196f3; }
  #data-flow-demo .log { font-size: 12px; color: #666; height: 100px; overflow-y: auto; border: 1px solid #eee; padding: 5px; margin-top: 10px; background: #f9f9f9; }
</style>

<script>
  (function() {
    // 단방향
    const owInput = document.getElementById('one-way-input');
    const owState = document.getElementById('one-way-state');
    const owLog = document.getElementById('one-way-log');
    const owNodes = [
      document.getElementById('ow-node-1'),
      document.getElementById('ow-node-2'),
      document.getElementById('ow-node-3')
    ];


    owInput.addEventListener('input', (e) => {
      const val = e.target.value;
      addLog(owLog, `[Action] 유저 입력 발생: ${val}`);


      setTimeout(() => {
        owState.innerText = `"${val}"`;
        addLog(owLog, `[State Update] 중앙 저장소 데이터 갱신`);


        owNodes.forEach((node, index) => {
          setTimeout(() => {
            node.querySelector('.val').innerText = `"${val}"`;
            node.classList.add('active');
            addLog(owLog, `[Render] 하위 컴포넌트 ${index+1} 갱신`);
            setTimeout(() => node.classList.remove('active'), 300);
          }, index * 100);
        });
      }, 200);
    });


    // 양방향
    const twInput = document.getElementById('two-way-input');
    const twState = document.getElementById('two-way-state');
    const twLog = document.getElementById('two-way-log');
    const twNodes = [
      document.getElementById('tw-node-1'),
      document.getElementById('tw-node-2'),
      document.getElementById('tw-node-3')
    ];


    twInput.addEventListener('input', (e) => {
      const val = e.target.value;
      twState.innerText = `"${val}"`;
      addLog(twLog, `[Sync] Model 데이터 즉시 변경`);


      twNodes.forEach(node => {
        node.querySelector('.val').innerText = `"${val}"`;
        node.classList.add('active');
        setTimeout(() => node.classList.remove('active'), 300);
      });
      addLog(twLog, `[Update] 연결된 모든 View 동시 갱신`);
    });


    function addLog(container, text) {
      const entry = document.createElement('div');
      entry.innerText = `> ${text}`;
      container.prepend(entry);
    }
  })();
</script>

단방향의 경우에는 어느 컴포넌트가 작동했는지 눈에 들어올 것이다. 그러나 양방향의 경우에는 컴포넌트가 동시에 갱신되어 어느부분이 작동하는지 한눈에 들어오지 않을 것이다. 이 상태에서 양방향의 컴포넌트 개수가 많아진다면 유지보수가 어려울 것이다.

...작성중...